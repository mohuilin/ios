// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protofile.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Protofile.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ProtofileRoot

@implementation ProtofileRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ProtofileRoot_FileDescriptor

static GPBFileDescriptor *ProtofileRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ChatType

GPBEnumDescriptor *ChatType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Private\000Groupchat\000ConnectSystem\000";
    static const int32_t values[] = {
        ChatType_Private,
        ChatType_Groupchat,
        ChatType_ConnectSystem,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChatType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChatType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChatType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChatType_Private:
    case ChatType_Groupchat:
    case ChatType_ConnectSystem:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Announcement

@implementation Announcement

@dynamic createdAt;
@dynamic title;
@dynamic content;
@dynamic URL;
@dynamic category;
@dynamic desc;
@dynamic coversURL;

typedef struct Announcement__storage_ {
  uint32_t _has_storage_[1];
  float createdAt;
  int32_t category;
  NSString *title;
  NSString *content;
  NSString *URL;
  NSString *desc;
  NSString *coversURL;
} Announcement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_CreatedAt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Announcement__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Announcement__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Announcement__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Announcement__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_Category,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Announcement__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_Desc,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Announcement__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coversURL",
        .dataTypeSpecific.className = NULL,
        .number = Announcement_FieldNumber_CoversURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Announcement__storage_, coversURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Announcement class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Announcement__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004!!!\000\007\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemRedPackage

@implementation SystemRedPackage

@dynamic amount;
@dynamic hashId;
@dynamic tips;

typedef struct SystemRedPackage__storage_ {
  uint32_t _has_storage_[1];
  NSString *hashId;
  NSString *tips;
  int64_t amount;
} SystemRedPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = SystemRedPackage_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemRedPackage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = SystemRedPackage_FieldNumber_HashId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemRedPackage__storage_, hashId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = SystemRedPackage_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SystemRedPackage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemRedPackage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemRedPackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemTransferPackage

@implementation SystemTransferPackage

@dynamic amount;
@dynamic txid;
@dynamic tips;
@dynamic sender;

typedef struct SystemTransferPackage__storage_ {
  uint32_t _has_storage_[1];
  NSString *txid;
  NSString *tips;
  NSString *sender;
  int64_t amount;
} SystemTransferPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = SystemTransferPackage_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemTransferPackage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = SystemTransferPackage_FieldNumber_Txid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemTransferPackage__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = SystemTransferPackage_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SystemTransferPackage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = SystemTransferPackage_FieldNumber_Sender,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SystemTransferPackage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemTransferPackage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemTransferPackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Voice

@implementation Voice

@dynamic URL;
@dynamic duration;

typedef struct Voice__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  int64_t duration;
} Voice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Voice_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Voice__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = Voice_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Voice__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Voice class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Voice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Image

@implementation Image

@dynamic URL;
@dynamic width;
@dynamic height;

typedef struct Image__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *width;
  NSString *height;
} Image__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Image_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Image__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = Image_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Image__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = Image_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Image__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Image class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Image__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Location

@implementation Location

@dynamic longitude;
@dynamic latitude;
@dynamic address;

typedef struct Location__storage_ {
  uint32_t _has_storage_[1];
  NSString *longitude;
  NSString *latitude;
  NSString *address;
} Location__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = Location_FieldNumber_Longitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Location__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = Location_FieldNumber_Latitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Location__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Location_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Location__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Location class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Location__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemRedpackgeNotice

@implementation SystemRedpackgeNotice

@dynamic hasReceiver, receiver;
@dynamic amount;
@dynamic hashid;

typedef struct SystemRedpackgeNotice__storage_ {
  uint32_t _has_storage_[1];
  UserInfo *receiver;
  NSString *hashid;
  int64_t amount;
} SystemRedpackgeNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "receiver",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = SystemRedpackgeNotice_FieldNumber_Receiver,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemRedpackgeNotice__storage_, receiver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = SystemRedpackgeNotice_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SystemRedpackgeNotice__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hashid",
        .dataTypeSpecific.className = NULL,
        .number = SystemRedpackgeNotice_FieldNumber_Hashid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SystemRedpackgeNotice__storage_, hashid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemRedpackgeNotice class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemRedpackgeNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Reviewed

@implementation Reviewed

@dynamic category;
@dynamic identifier;
@dynamic tips;
@dynamic hasUserInfo, userInfo;
@dynamic verificationCode;
@dynamic source;
@dynamic name;

typedef struct Reviewed__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  int32_t source;
  NSString *identifier;
  NSString *tips;
  UserInfo *userInfo;
  NSString *verificationCode;
  NSString *name;
} Reviewed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Reviewed__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_Identifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Reviewed__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Reviewed__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = Reviewed_FieldNumber_UserInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Reviewed__storage_, userInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verificationCode",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_VerificationCode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Reviewed__storage_, verificationCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_Source,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Reviewed__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Reviewed_FieldNumber_Name,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Reviewed__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Reviewed class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Reviewed__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\010\000\005\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressNotify

@implementation AddressNotify

@dynamic txId;
@dynamic amount;

typedef struct AddressNotify__storage_ {
  uint32_t _has_storage_[1];
  NSString *txId;
  int64_t amount;
} AddressNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txId",
        .dataTypeSpecific.className = NULL,
        .number = AddressNotify_FieldNumber_TxId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressNotify__storage_, txId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = AddressNotify_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressNotify__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressNotify class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReviewedResponse

@implementation ReviewedResponse

@dynamic category;
@dynamic identifier;
@dynamic name;
@dynamic success;

typedef struct ReviewedResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  NSString *identifier;
  NSString *name;
} ReviewedResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ReviewedResponse_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReviewedResponse__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = ReviewedResponse_FieldNumber_Identifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReviewedResponse__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ReviewedResponse_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReviewedResponse__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = ReviewedResponse_FieldNumber_Success,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReviewedResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReviewedResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendToUserMessage

@implementation SendToUserMessage

@dynamic hashId;
@dynamic operation;
@dynamic status;

typedef struct SendToUserMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *hashId;
  NSString *operation;
} SendToUserMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = SendToUserMessage_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendToUserMessage__storage_, hashId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "operation",
        .dataTypeSpecific.className = NULL,
        .number = SendToUserMessage_FieldNumber_Operation,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendToUserMessage__storage_, operation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = SendToUserMessage_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendToUserMessage__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendToUserMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendToUserMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ComposeRequest

@implementation ComposeRequest

@dynamic addressesArray, addressesArray_Count;
@dynamic amount;
@dynamic sendLength;

typedef struct ComposeRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t sendLength;
  NSMutableArray *addressesArray;
  uint64_t amount;
} ComposeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = ComposeRequest_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ComposeRequest__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = ComposeRequest_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ComposeRequest__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "sendLength",
        .dataTypeSpecific.className = NULL,
        .number = ComposeRequest_FieldNumber_SendLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ComposeRequest__storage_, sendLength),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ComposeRequest class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ComposeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HttpServerResponse

@implementation HttpServerResponse

@dynamic code;
@dynamic message;
@dynamic body;

typedef struct HttpServerResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *message;
  NSData *body;
} HttpServerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = HttpServerResponse_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HttpServerResponse__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = HttpServerResponse_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HttpServerResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = HttpServerResponse_FieldNumber_Body,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HttpServerResponse__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HttpServerResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HttpServerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HttpResponse

@implementation HttpResponse

@dynamic code;
@dynamic message;
@dynamic hasBody, body;

typedef struct HttpResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *message;
  IMResponse *body;
} HttpResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = HttpResponse_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HttpResponse__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = HttpResponse_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HttpResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = GPBStringifySymbol(IMResponse),
        .number = HttpResponse_FieldNumber_Body,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HttpResponse__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HttpResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HttpResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HttpNotSignResponse

@implementation HttpNotSignResponse

@dynamic code;
@dynamic message;
@dynamic body;

typedef struct HttpNotSignResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *message;
  NSData *body;
} HttpNotSignResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = HttpNotSignResponse_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HttpNotSignResponse__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = HttpNotSignResponse_FieldNumber_Message,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HttpNotSignResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = HttpNotSignResponse_FieldNumber_Body,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HttpNotSignResponse__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HttpNotSignResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HttpNotSignResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserAddress

@implementation UserAddress

@dynamic address;

typedef struct UserAddress__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} UserAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = UserAddress_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserAddress__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserAddress class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfo

@implementation UserInfo

@dynamic username;
@dynamic avatar;
@dynamic pubKey;
@dynamic address;
@dynamic recommend;
@dynamic connectId;
@dynamic source;

typedef struct UserInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *username;
  NSString *avatar;
  NSString *pubKey;
  NSString *address;
  NSString *connectId;
} UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfo__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Avatar,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfo__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfo__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Address,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfo__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "recommend",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Recommend,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "connectId",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_ConnectId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserInfo__storage_, connectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Source,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UserInfo__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UsersInfo

@implementation UsersInfo

@dynamic usersArray, usersArray_Count;

typedef struct UsersInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
} UsersInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = UsersInfo_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UsersInfo__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UsersInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UsersInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhoneBookUserInfo

@implementation PhoneBookUserInfo

@dynamic phoneHash;
@dynamic hasUser, user;

typedef struct PhoneBookUserInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *phoneHash;
  UserInfo *user;
} PhoneBookUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phoneHash",
        .dataTypeSpecific.className = NULL,
        .number = PhoneBookUserInfo_FieldNumber_PhoneHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PhoneBookUserInfo__storage_, phoneHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = PhoneBookUserInfo_FieldNumber_User,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PhoneBookUserInfo__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhoneBookUserInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhoneBookUserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhoneBookUsersInfo

@implementation PhoneBookUsersInfo

@dynamic usersArray, usersArray_Count;

typedef struct PhoneBookUsersInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *usersArray;
} PhoneBookUsersInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PhoneBookUserInfo),
        .number = PhoneBookUsersInfo_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PhoneBookUsersInfo__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhoneBookUsersInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhoneBookUsersInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserExistedToken

@implementation UserExistedToken

@dynamic token;
@dynamic hasUserInfo, userInfo;
@dynamic binding;

typedef struct UserExistedToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  UserInfo *userInfo;
} UserExistedToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = UserExistedToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserExistedToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = UserExistedToken_FieldNumber_UserInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserExistedToken__storage_, userInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "binding",
        .dataTypeSpecific.className = NULL,
        .number = UserExistedToken_FieldNumber_Binding,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserExistedToken class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserExistedToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserPrivateSign

@implementation UserPrivateSign

@dynamic token;
@dynamic encryptionPri;
@dynamic passwordHint;

typedef struct UserPrivateSign__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
  NSString *encryptionPri;
  NSString *passwordHint;
} UserPrivateSign__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = UserPrivateSign_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserPrivateSign__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryptionPri",
        .dataTypeSpecific.className = NULL,
        .number = UserPrivateSign_FieldNumber_EncryptionPri,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserPrivateSign__storage_, encryptionPri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "passwordHint",
        .dataTypeSpecific.className = NULL,
        .number = UserPrivateSign_FieldNumber_PasswordHint,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserPrivateSign__storage_, passwordHint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserPrivateSign class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserPrivateSign__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SessionInfo

@implementation SessionInfo

@dynamic address;
@dynamic mute;

typedef struct SessionInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} SessionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = SessionInfo_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SessionInfo__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mute",
        .dataTypeSpecific.className = NULL,
        .number = SessionInfo_FieldNumber_Mute,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SessionInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SessionInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SettingUserInfo

@implementation SettingUserInfo

@dynamic avatar;
@dynamic username;

typedef struct SettingUserInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *avatar;
  NSString *username;
} SettingUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = SettingUserInfo_FieldNumber_Avatar,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SettingUserInfo__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = SettingUserInfo_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SettingUserInfo__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SettingUserInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SettingUserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Tag

@implementation Tag

@dynamic name;

typedef struct Tag__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} Tag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Tag_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Tag__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Tag class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Tag__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserIdentifier

@implementation UserIdentifier

@dynamic address;

typedef struct UserIdentifier__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} UserIdentifier__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = UserIdentifier_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserIdentifier__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserIdentifier class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserIdentifier__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TagList

@implementation TagList

@dynamic listArray, listArray_Count;

typedef struct TagList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} TagList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = NULL,
        .number = TagList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TagList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TagList class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TagList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetingUserToTag

@implementation SetingUserToTag

@dynamic address;
@dynamic name;

typedef struct SetingUserToTag__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *name;
} SetingUserToTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = SetingUserToTag_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetingUserToTag__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = SetingUserToTag_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetingUserToTag__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetingUserToTag class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetingUserToTag__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfoDetail

@implementation UserInfoDetail

@dynamic username;
@dynamic avatar;
@dynamic pubKey;
@dynamic address;
@dynamic passwordHint;
@dynamic encryptionPri;
@dynamic connectId;

typedef struct UserInfoDetail__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
  NSString *avatar;
  NSString *pubKey;
  NSString *address;
  NSString *passwordHint;
  NSString *encryptionPri;
  NSString *connectId;
} UserInfoDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoDetail_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfoDetail__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoDetail_FieldNumber_Avatar,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfoDetail__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoDetail_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfoDetail__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoDetail_FieldNumber_Address,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfoDetail__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "passwordHint",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoDetail_FieldNumber_PasswordHint,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserInfoDetail__storage_, passwordHint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryptionPri",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoDetail_FieldNumber_EncryptionPri,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserInfoDetail__storage_, encryptionPri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectId",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoDetail_FieldNumber_ConnectId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserInfoDetail__storage_, connectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfoDetail class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfoDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfoBalance

@implementation UserInfoBalance

@dynamic username;
@dynamic avatar;
@dynamic pubKey;
@dynamic address;
@dynamic balance;
@dynamic type;

typedef struct UserInfoBalance__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
  NSString *avatar;
  NSString *pubKey;
  NSString *address;
  NSString *type;
  uint64_t balance;
} UserInfoBalance__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoBalance_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfoBalance__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoBalance_FieldNumber_Avatar,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfoBalance__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoBalance_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfoBalance__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoBalance_FieldNumber_Address,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfoBalance__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoBalance_FieldNumber_Balance,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserInfoBalance__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoBalance_FieldNumber_Type,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserInfoBalance__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfoBalance class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfoBalance__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchUser

@implementation SearchUser

@dynamic criteria;

typedef struct SearchUser__storage_ {
  uint32_t _has_storage_[1];
  NSString *criteria;
} SearchUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "criteria",
        .dataTypeSpecific.className = NULL,
        .number = SearchUser_FieldNumber_Criteria,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchUser__storage_, criteria),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchUser class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendRecords

@implementation FriendRecords

@dynamic selfAddress;
@dynamic friendAddress;
@dynamic pageSize;
@dynamic pageIndex;

typedef struct FriendRecords__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  int32_t pageIndex;
  NSString *selfAddress;
  NSString *friendAddress;
} FriendRecords__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "selfAddress",
        .dataTypeSpecific.className = NULL,
        .number = FriendRecords_FieldNumber_SelfAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendRecords__storage_, selfAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "friendAddress",
        .dataTypeSpecific.className = NULL,
        .number = FriendRecords_FieldNumber_FriendAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FriendRecords__storage_, friendAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = FriendRecords_FieldNumber_PageSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FriendRecords__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageIndex",
        .dataTypeSpecific.className = NULL,
        .number = FriendRecords_FieldNumber_PageIndex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FriendRecords__storage_, pageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendRecords class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendRecords__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\010\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendBill

@implementation FriendBill

@dynamic createdAt;
@dynamic amount;
@dynamic status;
@dynamic category;
@dynamic txId;

typedef struct FriendBill__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *category;
  NSString *txId;
  int64_t createdAt;
  uint64_t amount;
} FriendBill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = FriendBill_FieldNumber_CreatedAt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendBill__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = FriendBill_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FriendBill__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = FriendBill_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FriendBill__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = FriendBill_FieldNumber_Category,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FriendBill__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txId",
        .dataTypeSpecific.className = NULL,
        .number = FriendBill_FieldNumber_TxId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FriendBill__storage_, txId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendBill class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendBill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendBillsMessage

@implementation FriendBillsMessage

@dynamic friendBillsArray, friendBillsArray_Count;

typedef struct FriendBillsMessage__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *friendBillsArray;
} FriendBillsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "friendBillsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FriendBill),
        .number = FriendBillsMessage_FieldNumber_FriendBillsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FriendBillsMessage__storage_, friendBillsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendBillsMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendBillsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000friendBills\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConnectId

@implementation ConnectId

@dynamic connectId;

typedef struct ConnectId__storage_ {
  uint32_t _has_storage_[1];
  NSString *connectId;
} ConnectId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "connectId",
        .dataTypeSpecific.className = NULL,
        .number = ConnectId_FieldNumber_ConnectId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConnectId__storage_, connectId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConnectId class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConnectId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Recommend

@implementation Recommend

@dynamic recommend;

typedef struct Recommend__storage_ {
  uint32_t _has_storage_[1];
} Recommend__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "recommend",
        .dataTypeSpecific.className = NULL,
        .number = Recommend_FieldNumber_Recommend,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Recommend class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Recommend__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NOInterest

@implementation NOInterest

@dynamic address;

typedef struct NOInterest__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} NOInterest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = NOInterest_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NOInterest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NOInterest class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NOInterest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Privacy

@implementation Privacy

@dynamic address;
@dynamic phoneNum;
@dynamic verify;
@dynamic syncPhoneBook;
@dynamic recommend;

typedef struct Privacy__storage_ {
  uint32_t _has_storage_[1];
} Privacy__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Privacy_FieldNumber_Address,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "phoneNum",
        .dataTypeSpecific.className = NULL,
        .number = Privacy_FieldNumber_PhoneNum,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "verify",
        .dataTypeSpecific.className = NULL,
        .number = Privacy_FieldNumber_Verify,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "syncPhoneBook",
        .dataTypeSpecific.className = NULL,
        .number = Privacy_FieldNumber_SyncPhoneBook,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "recommend",
        .dataTypeSpecific.className = NULL,
        .number = Privacy_FieldNumber_Recommend,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Privacy class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Privacy__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceToken

@implementation DeviceToken

@dynamic apnsDeviceToken;
@dynamic xgDeviceToken;
@dynamic gcmDeviceToken;
@dynamic pushType;
@dynamic deviceId;
@dynamic locale;

typedef struct DeviceToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *apnsDeviceToken;
  NSString *xgDeviceToken;
  NSString *gcmDeviceToken;
  NSString *pushType;
  NSString *deviceId;
  NSString *locale;
} DeviceToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "apnsDeviceToken",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_ApnsDeviceToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, apnsDeviceToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "xgDeviceToken",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_XgDeviceToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, xgDeviceToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gcmDeviceToken",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_GcmDeviceToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, gcmDeviceToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushType",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_PushType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, pushType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_DeviceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locale",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Locale,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, locale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceToken class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MobileVerify

@implementation MobileVerify

@dynamic countryCode;
@dynamic number;
@dynamic code;

typedef struct MobileVerify__storage_ {
  uint32_t _has_storage_[1];
  int32_t countryCode;
  NSString *number;
  NSString *code;
} MobileVerify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "countryCode",
        .dataTypeSpecific.className = NULL,
        .number = MobileVerify_FieldNumber_CountryCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MobileVerify__storage_, countryCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = MobileVerify_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MobileVerify__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = MobileVerify_FieldNumber_Code,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MobileVerify__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MobileVerify class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MobileVerify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMobileCode

@implementation SendMobileCode

@dynamic mobile;
@dynamic category;

typedef struct SendMobileCode__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  NSString *mobile;
} SendMobileCode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = SendMobileCode_FieldNumber_Mobile,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMobileCode__storage_, mobile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = SendMobileCode_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendMobileCode__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMobileCode class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMobileCode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangeLoginPassword

@implementation ChangeLoginPassword

@dynamic passwordHint;
@dynamic encryptionPri;

typedef struct ChangeLoginPassword__storage_ {
  uint32_t _has_storage_[1];
  NSString *passwordHint;
  NSString *encryptionPri;
} ChangeLoginPassword__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "passwordHint",
        .dataTypeSpecific.className = NULL,
        .number = ChangeLoginPassword_FieldNumber_PasswordHint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChangeLoginPassword__storage_, passwordHint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryptionPri",
        .dataTypeSpecific.className = NULL,
        .number = ChangeLoginPassword_FieldNumber_EncryptionPri,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChangeLoginPassword__storage_, encryptionPri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChangeLoginPassword class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChangeLoginPassword__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentSetting

@implementation PaymentSetting

@dynamic payPin;
@dynamic noSecretPay;
@dynamic fee;

typedef struct PaymentSetting__storage_ {
  uint32_t _has_storage_[1];
  NSString *payPin;
  uint64_t fee;
} PaymentSetting__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payPin",
        .dataTypeSpecific.className = NULL,
        .number = PaymentSetting_FieldNumber_PayPin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentSetting__storage_, payPin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "noSecretPay",
        .dataTypeSpecific.className = NULL,
        .number = PaymentSetting_FieldNumber_NoSecretPay,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = PaymentSetting_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PaymentSetting__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentSetting class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentSetting__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhoneInfo

@implementation PhoneInfo

@dynamic code;
@dynamic mobile;

typedef struct PhoneInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  NSString *mobile;
} PhoneInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = PhoneInfo_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PhoneInfo__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = PhoneInfo_FieldNumber_Mobile,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PhoneInfo__storage_, mobile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhoneInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhoneInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhoneBook

@implementation PhoneBook

@dynamic mobilesArray, mobilesArray_Count;

typedef struct PhoneBook__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *mobilesArray;
} PhoneBook__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mobilesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PhoneInfo),
        .number = PhoneBook_FieldNumber_MobilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PhoneBook__storage_, mobilesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhoneBook class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhoneBook__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SecurityToken

@implementation SecurityToken

@dynamic token;

typedef struct SecurityToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} SecurityToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = SecurityToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SecurityToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SecurityToken class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SecurityToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GenerateToken

@implementation GenerateToken

@dynamic salt;

typedef struct GenerateToken__storage_ {
  uint32_t _has_storage_[1];
  NSData *salt;
} GenerateToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = GenerateToken_FieldNumber_Salt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenerateToken__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenerateToken class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenerateToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterUser

@implementation RegisterUser

@dynamic username;
@dynamic avatar;
@dynamic mobile;
@dynamic token;
@dynamic encryptionPri;
@dynamic passwordHint;

typedef struct RegisterUser__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
  NSString *avatar;
  NSString *mobile;
  NSString *token;
  NSString *encryptionPri;
  NSString *passwordHint;
} RegisterUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = RegisterUser_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterUser__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = RegisterUser_FieldNumber_Avatar,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterUser__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = RegisterUser_FieldNumber_Mobile,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RegisterUser__storage_, mobile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = RegisterUser_FieldNumber_Token,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RegisterUser__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryptionPri",
        .dataTypeSpecific.className = NULL,
        .number = RegisterUser_FieldNumber_EncryptionPri,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RegisterUser__storage_, encryptionPri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "passwordHint",
        .dataTypeSpecific.className = NULL,
        .number = RegisterUser_FieldNumber_PasswordHint,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RegisterUser__storage_, passwordHint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterUser class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GenerateTokenResponse

@implementation GenerateTokenResponse

@dynamic salt;
@dynamic expired;

typedef struct GenerateTokenResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *salt;
  int64_t expired;
} GenerateTokenResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = GenerateTokenResponse_FieldNumber_Salt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GenerateTokenResponse__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expired",
        .dataTypeSpecific.className = NULL,
        .number = GenerateTokenResponse_FieldNumber_Expired,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GenerateTokenResponse__storage_, expired),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GenerateTokenResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GenerateTokenResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveGroup

@implementation RemoveGroup

@dynamic name;
@dynamic groupId;

typedef struct RemoveGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *groupId;
} RemoveGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = RemoveGroup_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveGroup__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = RemoveGroup_FieldNumber_GroupId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemoveGroup__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveGroup class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveGroup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupApplyMessage

@implementation GroupApplyMessage

@dynamic applyData;
@dynamic messageId;

typedef struct GroupApplyMessage__storage_ {
  uint32_t _has_storage_[1];
  NSData *applyData;
  NSString *messageId;
} GroupApplyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "applyData",
        .dataTypeSpecific.className = NULL,
        .number = GroupApplyMessage_FieldNumber_ApplyData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupApplyMessage__storage_, applyData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = GroupApplyMessage_FieldNumber_MessageId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupApplyMessage__storage_, messageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupApplyMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupApplyMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInvite

@implementation GroupInvite

@dynamic inviteBy;
@dynamic identifier;
@dynamic tips;
@dynamic token;

typedef struct GroupInvite__storage_ {
  uint32_t _has_storage_[1];
  NSString *inviteBy;
  NSString *identifier;
  NSString *tips;
  NSString *token;
} GroupInvite__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inviteBy",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_InviteBy,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, inviteBy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_Identifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = GroupInvite_FieldNumber_Token,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupInvite__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInvite class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInvite__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInviteUser

@implementation GroupInviteUser

@dynamic addressesArray, addressesArray_Count;
@dynamic identifier;

typedef struct GroupInviteUser__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
  NSString *identifier;
} GroupInviteUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteUser_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInviteUser__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteUser_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInviteUser__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInviteUser class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInviteUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInviteResponse

@implementation GroupInviteResponse

@dynamic address;
@dynamic token;

typedef struct GroupInviteResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *token;
} GroupInviteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteResponse_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInviteResponse__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = GroupInviteResponse_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInviteResponse__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInviteResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInviteResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInviteResponseList

@implementation GroupInviteResponseList

@dynamic listArray, listArray_Count;

typedef struct GroupInviteResponseList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
} GroupInviteResponseList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupInviteResponse),
        .number = GroupInviteResponseList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInviteResponseList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInviteResponseList class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInviteResponseList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupUrl

@implementation GroupUrl

@dynamic URL;

typedef struct GroupUrl__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
} GroupUrl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = GroupUrl_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupUrl__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupUrl class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupUrl__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupScan

@implementation GroupScan

@dynamic identifier;
@dynamic hash_p;

typedef struct GroupScan__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *hash_p;
} GroupScan__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupScan_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupScan__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupScan_FieldNumber_Hash_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupScan__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupScan class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupScan__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupToken

@implementation GroupToken

@dynamic token;

typedef struct GroupToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} GroupToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = GroupToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupToken class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Group

@implementation Group

@dynamic identifier;
@dynamic name;
@dynamic summary;
@dynamic public_p;
@dynamic reviewed;
@dynamic avatar;

typedef struct Group__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *name;
  NSString *summary;
  NSString *avatar;
} Group__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Group__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Group__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "summary",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Summary,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Group__storage_, summary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "public_p",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Public_p,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "reviewed",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Reviewed,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = Group_FieldNumber_Avatar,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Group__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Group class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Group__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMember

@implementation GroupMember

@dynamic username;
@dynamic avatar;
@dynamic address;
@dynamic role;
@dynamic nick;
@dynamic pubKey;

typedef struct GroupMember__storage_ {
  uint32_t _has_storage_[1];
  int32_t role;
  NSString *username;
  NSString *avatar;
  NSString *address;
  NSString *nick;
  NSString *pubKey;
} GroupMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMember__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Avatar,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMember__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMember__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "role",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Role,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupMember__storage_, role),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nick",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_Nick,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupMember__storage_, nick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = GroupMember_FieldNumber_PubKey,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupMember__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMember class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMember__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupApplyChange

@implementation GroupApplyChange

@dynamic verificationCode;
@dynamic tips;
@dynamic source;
@dynamic tipsHistoryArray, tipsHistoryArray_Count;

typedef struct GroupApplyChange__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *verificationCode;
  NSString *tips;
  NSMutableArray *tipsHistoryArray;
} GroupApplyChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "verificationCode",
        .dataTypeSpecific.className = NULL,
        .number = GroupApplyChange_FieldNumber_VerificationCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupApplyChange__storage_, verificationCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = GroupApplyChange_FieldNumber_Tips,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupApplyChange__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = GroupApplyChange_FieldNumber_Source,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupApplyChange__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tipsHistoryArray",
        .dataTypeSpecific.className = NULL,
        .number = GroupApplyChange_FieldNumber_TipsHistoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupApplyChange__storage_, tipsHistoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupApplyChange class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupApplyChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupSetting

@implementation GroupSetting

@dynamic identifier;
@dynamic summary;
@dynamic public_p;
@dynamic reviewed;

typedef struct GroupSetting__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *summary;
} GroupSetting__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupSetting_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupSetting__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "summary",
        .dataTypeSpecific.className = NULL,
        .number = GroupSetting_FieldNumber_Summary,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupSetting__storage_, summary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "public_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupSetting_FieldNumber_Public_p,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "reviewed",
        .dataTypeSpecific.className = NULL,
        .number = GroupSetting_FieldNumber_Reviewed,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupSetting class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupSetting__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupAttorn

@implementation GroupAttorn

@dynamic address;
@dynamic identifier;

typedef struct GroupAttorn__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *identifier;
} GroupAttorn__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GroupAttorn_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupAttorn__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupAttorn_FieldNumber_Identifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupAttorn__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupAttorn class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupAttorn__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupApply

@implementation GroupApply

@dynamic identifier;
@dynamic hash_p;
@dynamic tips;
@dynamic source;

typedef struct GroupApply__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *identifier;
  NSString *hash_p;
  NSString *tips;
} GroupApply__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupApply_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupApply__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupApply_FieldNumber_Hash_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupApply__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = GroupApply_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupApply__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = GroupApply_FieldNumber_Source,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupApply__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupApply class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupApply__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupReviewed

@implementation GroupReviewed

@dynamic identifier;
@dynamic verificationCode;
@dynamic address;
@dynamic backup;

typedef struct GroupReviewed__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *verificationCode;
  NSString *address;
  NSString *backup;
} GroupReviewed__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupReviewed_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupReviewed__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verificationCode",
        .dataTypeSpecific.className = NULL,
        .number = GroupReviewed_FieldNumber_VerificationCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupReviewed__storage_, verificationCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = GroupReviewed_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupReviewed__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backup",
        .dataTypeSpecific.className = NULL,
        .number = GroupReviewed_FieldNumber_Backup,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupReviewed__storage_, backup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupReviewed class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupReviewed__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfoBase

@implementation GroupInfoBase

@dynamic avatar;
@dynamic summary;
@dynamic name;
@dynamic count;
@dynamic hash_p;
@dynamic public_p;
@dynamic joined;

typedef struct GroupInfoBase__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSString *avatar;
  NSString *summary;
  NSString *name;
  NSString *hash_p;
} GroupInfoBase__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBase_FieldNumber_Avatar,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfoBase__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "summary",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBase_FieldNumber_Summary,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInfoBase__storage_, summary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBase_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInfoBase__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBase_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupInfoBase__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBase_FieldNumber_Hash_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupInfoBase__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "public_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBase_FieldNumber_Public_p,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "joined",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBase_FieldNumber_Joined,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInfoBase class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfoBase__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfoBaseShare

@implementation GroupInfoBaseShare

@dynamic avatar;
@dynamic summary;
@dynamic name;
@dynamic count;
@dynamic hash_p;
@dynamic public_p;
@dynamic username;
@dynamic identifier;
@dynamic joined;

typedef struct GroupInfoBaseShare__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSString *avatar;
  NSString *summary;
  NSString *name;
  NSString *hash_p;
  NSString *username;
  NSString *identifier;
} GroupInfoBaseShare__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBaseShare_FieldNumber_Avatar,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfoBaseShare__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "summary",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBaseShare_FieldNumber_Summary,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInfoBaseShare__storage_, summary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBaseShare_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInfoBaseShare__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBaseShare_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupInfoBaseShare__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBaseShare_FieldNumber_Hash_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupInfoBaseShare__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "public_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBaseShare_FieldNumber_Public_p,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBaseShare_FieldNumber_Username,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GroupInfoBaseShare__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBaseShare_FieldNumber_Identifier,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GroupInfoBaseShare__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "joined",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfoBaseShare_FieldNumber_Joined,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInfoBaseShare class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfoBaseShare__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupInfo

@implementation GroupInfo

@dynamic hasGroup, group;
@dynamic membersArray, membersArray_Count;
@dynamic backup;
@dynamic ecdh;

typedef struct GroupInfo__storage_ {
  uint32_t _has_storage_[1];
  Group *group;
  NSMutableArray *membersArray;
  NSString *backup;
  NSString *ecdh;
} GroupInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "group",
        .dataTypeSpecific.className = GPBStringifySymbol(Group),
        .number = GroupInfo_FieldNumber_Group,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "membersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupMember),
        .number = GroupInfo_FieldNumber_MembersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, membersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "backup",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfo_FieldNumber_Backup,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, backup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ecdh",
        .dataTypeSpecific.className = NULL,
        .number = GroupInfo_FieldNumber_Ecdh,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupInfo__storage_, ecdh),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupHash

@implementation GroupHash

@dynamic hash_p;
@dynamic expired;

typedef struct GroupHash__storage_ {
  uint32_t _has_storage_[1];
  NSString *hash_p;
  int64_t expired;
} GroupHash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupHash_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupHash__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expired",
        .dataTypeSpecific.className = NULL,
        .number = GroupHash_FieldNumber_Expired,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupHash__storage_, expired),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupHash class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupHash__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupSettingInfo

@implementation GroupSettingInfo

@dynamic public_p;
@dynamic reviewed;
@dynamic avatar;
@dynamic summary;
@dynamic mute;

typedef struct GroupSettingInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *avatar;
  NSString *summary;
} GroupSettingInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "public_p",
        .dataTypeSpecific.className = NULL,
        .number = GroupSettingInfo_FieldNumber_Public_p,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "reviewed",
        .dataTypeSpecific.className = NULL,
        .number = GroupSettingInfo_FieldNumber_Reviewed,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = GroupSettingInfo_FieldNumber_Avatar,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupSettingInfo__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "summary",
        .dataTypeSpecific.className = NULL,
        .number = GroupSettingInfo_FieldNumber_Summary,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GroupSettingInfo__storage_, summary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mute",
        .dataTypeSpecific.className = NULL,
        .number = GroupSettingInfo_FieldNumber_Mute,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupSettingInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupSettingInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateGroup

@implementation CreateGroup

@dynamic name;
@dynamic summary;
@dynamic public_p;
@dynamic usersArray, usersArray_Count;
@dynamic reviewed;

typedef struct CreateGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *summary;
  NSMutableArray *usersArray;
} CreateGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = CreateGroup_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateGroup__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "summary",
        .dataTypeSpecific.className = NULL,
        .number = CreateGroup_FieldNumber_Summary,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateGroup__storage_, summary),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "public_p",
        .dataTypeSpecific.className = NULL,
        .number = CreateGroup_FieldNumber_Public_p,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AddGroupUserInfo),
        .number = CreateGroup_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CreateGroup__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reviewed",
        .dataTypeSpecific.className = NULL,
        .number = CreateGroup_FieldNumber_Reviewed,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateGroup class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateGroup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddUserToGroup

@implementation AddUserToGroup

@dynamic identifier;
@dynamic usersArray, usersArray_Count;

typedef struct AddUserToGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSMutableArray *usersArray;
} AddUserToGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = AddUserToGroup_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddUserToGroup__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "usersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AddGroupUserInfo),
        .number = AddUserToGroup_FieldNumber_UsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddUserToGroup__storage_, usersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddUserToGroup class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddUserToGroup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddGroupUserInfo

@implementation AddGroupUserInfo

@dynamic address;
@dynamic backup;

typedef struct AddGroupUserInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *backup;
} AddGroupUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AddGroupUserInfo_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddGroupUserInfo__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "backup",
        .dataTypeSpecific.className = NULL,
        .number = AddGroupUserInfo_FieldNumber_Backup,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddGroupUserInfo__storage_, backup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddGroupUserInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddGroupUserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelOrQuitGroupMember

@implementation DelOrQuitGroupMember

@dynamic identifier;
@dynamic address;

typedef struct DelOrQuitGroupMember__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *address;
} DelOrQuitGroupMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = DelOrQuitGroupMember_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelOrQuitGroupMember__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = DelOrQuitGroupMember_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelOrQuitGroupMember__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelOrQuitGroupMember class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelOrQuitGroupMember__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateGroupInfo

@implementation UpdateGroupInfo

@dynamic identifier;
@dynamic name;

typedef struct UpdateGroupInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *name;
} UpdateGroupInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = UpdateGroupInfo_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateGroupInfo__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = UpdateGroupInfo_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateGroupInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateGroupInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateGroupInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateGroupMemberInfo

@implementation UpdateGroupMemberInfo

@dynamic identifier;
@dynamic nick;

typedef struct UpdateGroupMemberInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *nick;
} UpdateGroupMemberInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = UpdateGroupMemberInfo_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateGroupMemberInfo__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nick",
        .dataTypeSpecific.className = NULL,
        .number = UpdateGroupMemberInfo_FieldNumber_Nick,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateGroupMemberInfo__storage_, nick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateGroupMemberInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateGroupMemberInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateGroupMute

@implementation UpdateGroupMute

@dynamic identifier;
@dynamic mute;

typedef struct UpdateGroupMute__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
} UpdateGroupMute__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = UpdateGroupMute_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateGroupMute__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mute",
        .dataTypeSpecific.className = NULL,
        .number = UpdateGroupMute_FieldNumber_Mute,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateGroupMute class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateGroupMute__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupCollaborative

@implementation GroupCollaborative

@dynamic identifier;
@dynamic collaborative;

typedef struct GroupCollaborative__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *collaborative;
} GroupCollaborative__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupCollaborative_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupCollaborative__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "collaborative",
        .dataTypeSpecific.className = NULL,
        .number = GroupCollaborative_FieldNumber_Collaborative,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupCollaborative__storage_, collaborative),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupCollaborative class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupCollaborative__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommonGroup

@implementation CommonGroup

@dynamic identifiersArray, identifiersArray_Count;

typedef struct CommonGroup__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identifiersArray;
} CommonGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifiersArray",
        .dataTypeSpecific.className = NULL,
        .number = CommonGroup_FieldNumber_IdentifiersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CommonGroup__storage_, identifiersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommonGroup class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommonGroup__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserCommonGroups

@implementation UserCommonGroups

@dynamic groupsArray, groupsArray_Count;

typedef struct UserCommonGroups__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *groupsArray;
} UserCommonGroups__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GroupInfo),
        .number = UserCommonGroups_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserCommonGroups__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserCommonGroups class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserCommonGroups__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupId

@implementation GroupId

@dynamic identifier;

typedef struct GroupId__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
} GroupId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupId_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupId__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupId class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupChange

@implementation GroupChange

@dynamic identifier;
@dynamic changeType;
@dynamic detail;
@dynamic count;
@dynamic hasInviteBy, inviteBy;

typedef struct GroupChange__storage_ {
  uint32_t _has_storage_[1];
  int32_t changeType;
  int32_t count;
  NSString *identifier;
  NSData *detail;
  UserInfo *inviteBy;
} GroupChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupChange_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupChange__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "changeType",
        .dataTypeSpecific.className = NULL,
        .number = GroupChange_FieldNumber_ChangeType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupChange__storage_, changeType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = GroupChange_FieldNumber_Detail,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupChange__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = GroupChange_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GroupChange__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inviteBy",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = GroupChange_FieldNumber_InviteBy,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GroupChange__storage_, inviteBy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupChange class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QuitGroupUserAddress

@implementation QuitGroupUserAddress

@dynamic addressesArray, addressesArray_Count;

typedef struct QuitGroupUserAddress__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
} QuitGroupUserAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = QuitGroupUserAddress_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QuitGroupUserAddress__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QuitGroupUserAddress class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QuitGroupUserAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangeGroupNick

@implementation ChangeGroupNick

@dynamic address;
@dynamic nick;

typedef struct ChangeGroupNick__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *nick;
} ChangeGroupNick__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = ChangeGroupNick_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChangeGroupNick__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nick",
        .dataTypeSpecific.className = NULL,
        .number = ChangeGroupNick_FieldNumber_Nick,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChangeGroupNick__storage_, nick),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChangeGroupNick class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChangeGroupNick__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DownloadBackUpResp

@implementation DownloadBackUpResp

@dynamic backup;

typedef struct DownloadBackUpResp__storage_ {
  uint32_t _has_storage_[1];
  NSString *backup;
} DownloadBackUpResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "backup",
        .dataTypeSpecific.className = NULL,
        .number = DownloadBackUpResp_FieldNumber_Backup,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DownloadBackUpResp__storage_, backup),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DownloadBackUpResp class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DownloadBackUpResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupAvatar

@implementation GroupAvatar

@dynamic file;
@dynamic identifier;

typedef struct GroupAvatar__storage_ {
  uint32_t _has_storage_[1];
  NSData *file;
  NSString *identifier;
} GroupAvatar__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "file",
        .dataTypeSpecific.className = NULL,
        .number = GroupAvatar_FieldNumber_File,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupAvatar__storage_, file),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = GroupAvatar_FieldNumber_Identifier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupAvatar__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupAvatar class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupAvatar__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupAvatarResponse

@implementation GroupAvatarResponse

@dynamic URL;

typedef struct GroupAvatarResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
} GroupAvatarResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = GroupAvatarResponse_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupAvatarResponse__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupAvatarResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupAvatarResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GcmData

@implementation GcmData

@dynamic iv;
@dynamic aad;
@dynamic tag;
@dynamic ciphertext;

typedef struct GcmData__storage_ {
  uint32_t _has_storage_[1];
  NSData *iv;
  NSData *aad;
  NSData *tag;
  NSData *ciphertext;
} GcmData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "iv",
        .dataTypeSpecific.className = NULL,
        .number = GcmData_FieldNumber_Iv,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GcmData__storage_, iv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "aad",
        .dataTypeSpecific.className = NULL,
        .number = GcmData_FieldNumber_Aad,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GcmData__storage_, aad),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag",
        .dataTypeSpecific.className = NULL,
        .number = GcmData_FieldNumber_Tag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GcmData__storage_, tag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ciphertext",
        .dataTypeSpecific.className = NULL,
        .number = GcmData_FieldNumber_Ciphertext,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GcmData__storage_, ciphertext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GcmData class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GcmData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMResponse

@implementation IMResponse

@dynamic sign;
@dynamic hasCipherData, cipherData;

typedef struct IMResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *sign;
  GcmData *cipherData;
} IMResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = IMResponse_FieldNumber_Sign,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMResponse__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cipherData",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = IMResponse_FieldNumber_CipherData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMResponse__storage_, cipherData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DBPassword

@implementation DBPassword

@dynamic pubKey;
@dynamic salt;

typedef struct DBPassword__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSData *salt;
} DBPassword__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = DBPassword_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DBPassword__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = DBPassword_FieldNumber_Salt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DBPassword__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DBPassword class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DBPassword__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RequestNotEncrypt

@implementation RequestNotEncrypt

@dynamic pubKey;
@dynamic sign;
@dynamic body;

typedef struct RequestNotEncrypt__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSString *sign;
  NSData *body;
} RequestNotEncrypt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = RequestNotEncrypt_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RequestNotEncrypt__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = RequestNotEncrypt_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RequestNotEncrypt__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = RequestNotEncrypt_FieldNumber_Body,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RequestNotEncrypt__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RequestNotEncrypt class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RequestNotEncrypt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMRequest

@implementation IMRequest

@dynamic pubKey;
@dynamic sign;
@dynamic hasCipherData, cipherData;

typedef struct IMRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSString *sign;
  GcmData *cipherData;
} IMRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = IMRequest_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMRequest__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = IMRequest_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMRequest__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cipherData",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = IMRequest_FieldNumber_CipherData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IMRequest__storage_, cipherData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMRequest class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMTransferData

@implementation IMTransferData

@dynamic sign;
@dynamic hasCipherData, cipherData;

typedef struct IMTransferData__storage_ {
  uint32_t _has_storage_[1];
  NSString *sign;
  GcmData *cipherData;
} IMTransferData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = IMTransferData_FieldNumber_Sign,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMTransferData__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cipherData",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = IMTransferData_FieldNumber_CipherData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMTransferData__storage_, cipherData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMTransferData class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMTransferData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Ack

@implementation Ack

@dynamic msgId;
@dynamic type;

typedef struct Ack__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSString *msgId;
} Ack__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = Ack_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Ack__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = Ack_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Ack__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Ack class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Ack__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatCacheCookie

@implementation ChatCacheCookie

@dynamic chatPubKey;
@dynamic salt;
@dynamic chatPrivkey;

typedef struct ChatCacheCookie__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatPubKey;
  NSData *salt;
  NSString *chatPrivkey;
} ChatCacheCookie__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatPubKey",
        .dataTypeSpecific.className = NULL,
        .number = ChatCacheCookie_FieldNumber_ChatPubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatCacheCookie__storage_, chatPubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = ChatCacheCookie_FieldNumber_Salt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatCacheCookie__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "chatPrivkey",
        .dataTypeSpecific.className = NULL,
        .number = ChatCacheCookie_FieldNumber_ChatPrivkey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatCacheCookie__storage_, chatPrivkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatCacheCookie class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatCacheCookie__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatCookie

@implementation ChatCookie

@dynamic sign;
@dynamic hasData_p, data_p;

typedef struct ChatCookie__storage_ {
  uint32_t _has_storage_[1];
  NSString *sign;
  ChatCookieData *data_p;
} ChatCookie__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = ChatCookie_FieldNumber_Sign,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatCookie__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatCookieData),
        .number = ChatCookie_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatCookie__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatCookie class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatCookie__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatCookieData

@implementation ChatCookieData

@dynamic chatPubKey;
@dynamic salt;
@dynamic expired;

typedef struct ChatCookieData__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatPubKey;
  NSData *salt;
  int64_t expired;
} ChatCookieData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatPubKey",
        .dataTypeSpecific.className = NULL,
        .number = ChatCookieData_FieldNumber_ChatPubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatCookieData__storage_, chatPubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = ChatCookieData_FieldNumber_Salt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatCookieData__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expired",
        .dataTypeSpecific.className = NULL,
        .number = ChatCookieData_FieldNumber_Expired,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatCookieData__storage_, expired),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatCookieData class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatCookieData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendChatCookie

@implementation FriendChatCookie

@dynamic address;

typedef struct FriendChatCookie__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} FriendChatCookie__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = FriendChatCookie_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendChatCookie__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendChatCookie class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendChatCookie__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewConnection

@implementation NewConnection

@dynamic salt;
@dynamic pubKey;

typedef struct NewConnection__storage_ {
  uint32_t _has_storage_[1];
  NSData *salt;
  NSData *pubKey;
} NewConnection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = NewConnection_FieldNumber_Salt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewConnection__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = NewConnection_FieldNumber_PubKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewConnection__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewConnection class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewConnection__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Connection

@implementation Connection

@dynamic sign;
@dynamic token;

typedef struct Connection__storage_ {
  uint32_t _has_storage_[1];
  NSString *sign;
  NSString *token;
} Connection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = Connection_FieldNumber_Sign,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Connection__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = Connection_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Connection__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Connection class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Connection__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Handshake

@implementation Handshake

@dynamic pubKey;
@dynamic sign;

typedef struct Handshake__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSString *sign;
} Handshake__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = Handshake_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Handshake__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = Handshake_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Handshake__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Handshake class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Handshake__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommandStauts

@implementation CommandStauts

@dynamic status;

typedef struct CommandStauts__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} CommandStauts__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = CommandStauts_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommandStauts__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommandStauts class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommandStauts__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Command

@implementation Command

@dynamic msgId;
@dynamic detail;
@dynamic errNo;
@dynamic msg;

typedef struct Command__storage_ {
  uint32_t _has_storage_[1];
  int32_t errNo;
  NSString *msgId;
  NSData *detail;
  NSString *msg;
} Command__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = Command_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Command__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "detail",
        .dataTypeSpecific.className = NULL,
        .number = Command_FieldNumber_Detail,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Command__storage_, detail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "errNo",
        .dataTypeSpecific.className = NULL,
        .number = Command_FieldNumber_ErrNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Command__storage_, errNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = Command_FieldNumber_Msg,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Command__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Command class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Command__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommandDetail

@implementation CommandDetail

@dynamic cmdType;
@dynamic hasCmd, cmd;

typedef struct CommandDetail__storage_ {
  uint32_t _has_storage_[1];
  int32_t cmdType;
  Command *cmd;
} CommandDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cmdType",
        .dataTypeSpecific.className = NULL,
        .number = CommandDetail_FieldNumber_CmdType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommandDetail__storage_, cmdType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmd",
        .dataTypeSpecific.className = GPBStringifySymbol(Command),
        .number = CommandDetail_FieldNumber_Cmd,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CommandDetail__storage_, cmd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommandDetail class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommandDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceInfo

@implementation DeviceInfo

@dynamic deviceId;
@dynamic deviceName;
@dynamic locale;
@dynamic cv;
@dynamic uuid;
@dynamic hasChatCookieData, chatCookieData;

typedef struct DeviceInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t cv;
  NSString *deviceId;
  NSString *deviceName;
  NSString *locale;
  NSString *uuid;
  ChatCookieData *chatCookieData;
} DeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInfo_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInfo_FieldNumber_DeviceName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locale",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInfo_FieldNumber_Locale,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, locale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cv",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInfo_FieldNumber_Cv,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, cv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInfo_FieldNumber_Uuid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatCookieData",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatCookieData),
        .number = DeviceInfo_FieldNumber_ChatCookieData,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceInfo__storage_, chatCookieData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010\000\002\n\000\006\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QuitMessage

@implementation QuitMessage

@dynamic deviceName;

typedef struct QuitMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceName;
} QuitMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = QuitMessage_FieldNumber_DeviceName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QuitMessage__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QuitMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QuitMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Avatar

@implementation Avatar

@dynamic file;

typedef struct Avatar__storage_ {
  uint32_t _has_storage_[1];
  NSData *file;
} Avatar__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "file",
        .dataTypeSpecific.className = NULL,
        .number = Avatar_FieldNumber_File,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Avatar__storage_, file),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Avatar class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Avatar__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AvatarInfo

@implementation AvatarInfo

@dynamic URL;

typedef struct AvatarInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
} AvatarInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = AvatarInfo_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AvatarInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AvatarInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AvatarInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AvailableServers

@implementation AvailableServers

@dynamic server;

typedef struct AvailableServers__storage_ {
  uint32_t _has_storage_[1];
  NSString *server;
} AvailableServers__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "server",
        .dataTypeSpecific.className = NULL,
        .number = AvailableServers_FieldNumber_Server,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AvailableServers__storage_, server),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AvailableServers class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AvailableServers__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AvailableServersResponse

@implementation AvailableServersResponse

@dynamic hasServer, server;
@dynamic sign;

typedef struct AvailableServersResponse__storage_ {
  uint32_t _has_storage_[1];
  AvailableServers *server;
  NSString *sign;
} AvailableServersResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "server",
        .dataTypeSpecific.className = GPBStringifySymbol(AvailableServers),
        .number = AvailableServersResponse_FieldNumber_Server,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AvailableServersResponse__storage_, server),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = AvailableServersResponse_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AvailableServersResponse__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AvailableServersResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AvailableServersResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StructData

@implementation StructData

@dynamic random;
@dynamic plainData;

typedef struct StructData__storage_ {
  uint32_t _has_storage_[1];
  NSData *random;
  NSData *plainData;
} StructData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "random",
        .dataTypeSpecific.className = NULL,
        .number = StructData_FieldNumber_Random,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StructData__storage_, random),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "plainData",
        .dataTypeSpecific.className = NULL,
        .number = StructData_FieldNumber_PlainData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StructData__storage_, plainData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StructData class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StructData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VersionRequest

@implementation VersionRequest

@dynamic version;
@dynamic protocolVersion;
@dynamic category;
@dynamic platform;

typedef struct VersionRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t protocolVersion;
  int32_t category;
  int32_t platform;
  NSString *version;
} VersionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = VersionRequest_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VersionRequest__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "protocolVersion",
        .dataTypeSpecific.className = NULL,
        .number = VersionRequest_FieldNumber_ProtocolVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VersionRequest__storage_, protocolVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = VersionRequest_FieldNumber_Category,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VersionRequest__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "platform",
        .dataTypeSpecific.className = NULL,
        .number = VersionRequest_FieldNumber_Platform,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VersionRequest__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VersionRequest class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VersionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VersionResponse

@implementation VersionResponse

@dynamic version;
@dynamic protocolVersion;
@dynamic category;
@dynamic force;
@dynamic platform;
@dynamic remark;
@dynamic upgradeURL;

typedef struct VersionResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t protocolVersion;
  int32_t category;
  int32_t platform;
  NSString *version;
  NSString *remark;
  NSString *upgradeURL;
} VersionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = VersionResponse_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VersionResponse__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "protocolVersion",
        .dataTypeSpecific.className = NULL,
        .number = VersionResponse_FieldNumber_ProtocolVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VersionResponse__storage_, protocolVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = VersionResponse_FieldNumber_Category,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VersionResponse__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "force",
        .dataTypeSpecific.className = NULL,
        .number = VersionResponse_FieldNumber_Force,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "platform",
        .dataTypeSpecific.className = NULL,
        .number = VersionResponse_FieldNumber_Platform,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VersionResponse__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = VersionResponse_FieldNumber_Remark,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VersionResponse__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "upgradeURL",
        .dataTypeSpecific.className = NULL,
        .number = VersionResponse_FieldNumber_UpgradeURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VersionResponse__storage_, upgradeURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VersionResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VersionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\017\000\007\007\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RelationShip

@implementation RelationShip

@dynamic version;
@dynamic friendsArray, friendsArray_Count;

typedef struct RelationShip__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  NSMutableArray *friendsArray;
} RelationShip__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = RelationShip_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RelationShip__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "friendsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FriendInfo),
        .number = RelationShip_FieldNumber_FriendsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RelationShip__storage_, friendsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RelationShip class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RelationShip__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncRelationship

@implementation SyncRelationship

@dynamic version;

typedef struct SyncRelationship__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
} SyncRelationship__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = SyncRelationship_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncRelationship__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncRelationship class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncRelationship__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FriendInfo

@implementation FriendInfo

@dynamic username;
@dynamic avatar;
@dynamic pubKey;
@dynamic address;
@dynamic common;
@dynamic source;
@dynamic remark;

typedef struct FriendInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *username;
  NSString *avatar;
  NSString *pubKey;
  NSString *address;
  NSString *remark;
} FriendInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Avatar,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Address,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "common",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Common,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Source,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = FriendInfo_FieldNumber_Remark,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FriendInfo__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FriendInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FriendInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SettingFriendInfo

@implementation SettingFriendInfo

@dynamic address;
@dynamic remark;
@dynamic common;

typedef struct SettingFriendInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *remark;
} SettingFriendInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = SettingFriendInfo_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SettingFriendInfo__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = NULL,
        .number = SettingFriendInfo_FieldNumber_Remark,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SettingFriendInfo__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "common",
        .dataTypeSpecific.className = NULL,
        .number = SettingFriendInfo_FieldNumber_Common,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SettingFriendInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SettingFriendInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddFriendRequest

@implementation AddFriendRequest

@dynamic address;
@dynamic hasTips, tips;
@dynamic source;

typedef struct AddFriendRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *address;
  GcmData *tips;
} AddFriendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AddFriendRequest_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddFriendRequest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = AddFriendRequest_FieldNumber_Tips,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddFriendRequest__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = AddFriendRequest_FieldNumber_Source,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddFriendRequest__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFriendRequest class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFriendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AcceptFriendRequest

@implementation AcceptFriendRequest

@dynamic address;
@dynamic source;

typedef struct AcceptFriendRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  NSString *address;
} AcceptFriendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AcceptFriendRequest_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AcceptFriendRequest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = AcceptFriendRequest_FieldNumber_Source,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AcceptFriendRequest__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AcceptFriendRequest class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AcceptFriendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReceiveAcceptFriendRequest

@implementation ReceiveAcceptFriendRequest

@dynamic address;
@dynamic version;

typedef struct ReceiveAcceptFriendRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *version;
} ReceiveAcceptFriendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = ReceiveAcceptFriendRequest_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReceiveAcceptFriendRequest__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = ReceiveAcceptFriendRequest_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReceiveAcceptFriendRequest__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReceiveAcceptFriendRequest class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceiveAcceptFriendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveRelationship

@implementation RemoveRelationship

@dynamic address;

typedef struct RemoveRelationship__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} RemoveRelationship__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = RemoveRelationship_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveRelationship__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveRelationship class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveRelationship__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReceiveFriendRequest

@implementation ReceiveFriendRequest

@dynamic hasSender, sender;
@dynamic hasTips, tips;
@dynamic source;

typedef struct ReceiveFriendRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t source;
  UserInfo *sender;
  GcmData *tips;
} ReceiveFriendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = ReceiveFriendRequest_FieldNumber_Sender,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReceiveFriendRequest__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = ReceiveFriendRequest_FieldNumber_Tips,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReceiveFriendRequest__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = ReceiveFriendRequest_FieldNumber_Source,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReceiveFriendRequest__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReceiveFriendRequest class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceiveFriendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangeRecords

@implementation ChangeRecords

@dynamic version;
@dynamic changeRecordsArray, changeRecordsArray_Count;

typedef struct ChangeRecords__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  NSMutableArray *changeRecordsArray;
} ChangeRecords__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = ChangeRecords_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChangeRecords__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "changeRecordsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChangeRecord),
        .number = ChangeRecords_FieldNumber_ChangeRecordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChangeRecords__storage_, changeRecordsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChangeRecords class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChangeRecords__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000changeRecords\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangeRecord

@implementation ChangeRecord

@dynamic category;
@dynamic address;
@dynamic hasUserInfo, userInfo;

typedef struct ChangeRecord__storage_ {
  uint32_t _has_storage_[1];
  NSString *category;
  NSString *address;
  UserInfo *userInfo;
} ChangeRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = ChangeRecord_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChangeRecord__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = ChangeRecord_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChangeRecord__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = ChangeRecord_FieldNumber_UserInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChangeRecord__storage_, userInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChangeRecord class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChangeRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncUserRelationship

@implementation SyncUserRelationship

@dynamic hasRelationShip, relationShip;
@dynamic hasUserCommonGroups, userCommonGroups;

typedef struct SyncUserRelationship__storage_ {
  uint32_t _has_storage_[1];
  RelationShip *relationShip;
  UserCommonGroups *userCommonGroups;
} SyncUserRelationship__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "relationShip",
        .dataTypeSpecific.className = GPBStringifySymbol(RelationShip),
        .number = SyncUserRelationship_FieldNumber_RelationShip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncUserRelationship__storage_, relationShip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userCommonGroups",
        .dataTypeSpecific.className = GPBStringifySymbol(UserCommonGroups),
        .number = SyncUserRelationship_FieldNumber_UserCommonGroups,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncUserRelationship__storage_, userCommonGroups),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncUserRelationship class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncUserRelationship__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\002\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateMobileBind

@implementation UpdateMobileBind

@dynamic username;

typedef struct UpdateMobileBind__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
} UpdateMobileBind__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = UpdateMobileBind_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateMobileBind__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateMobileBind class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateMobileBind__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessagePost

@implementation MessagePost

@dynamic pubKey;
@dynamic sign;
@dynamic hasMsgData, msgData;

typedef struct MessagePost__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSString *sign;
  MessageData *msgData;
} MessagePost__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = MessagePost_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessagePost__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = MessagePost_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessagePost__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgData",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageData),
        .number = MessagePost_FieldNumber_MsgData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessagePost__storage_, msgData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessagePost class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessagePost__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageUserInfo

@implementation MessageUserInfo

@dynamic uid;
@dynamic username;
@dynamic avatar;

typedef struct MessageUserInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *uid;
  NSString *username;
  NSString *avatar;
} MessageUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = MessageUserInfo_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageUserInfo__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = MessageUserInfo_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageUserInfo__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = MessageUserInfo_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageUserInfo__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageUserInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageUserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatSession

@implementation ChatSession

@dynamic salt;
@dynamic ver;
@dynamic pubKey;

typedef struct ChatSession__storage_ {
  uint32_t _has_storage_[1];
  NSData *salt;
  NSData *ver;
  NSString *pubKey;
} ChatSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "salt",
        .dataTypeSpecific.className = NULL,
        .number = ChatSession_FieldNumber_Salt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatSession__storage_, salt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ver",
        .dataTypeSpecific.className = NULL,
        .number = ChatSession_FieldNumber_Ver,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatSession__storage_, ver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = ChatSession_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatSession__storage_, pubKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatSession class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatSession__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatMessage

@implementation ChatMessage

@dynamic msgId;
@dynamic msgTime;
@dynamic from;
@dynamic to;
@dynamic hasCipherData, cipherData;
@dynamic chatType;
@dynamic msgType;
@dynamic ext;
@dynamic sendStatus;

typedef struct ChatMessage__storage_ {
  uint32_t _has_storage_[1];
  ChatType chatType;
  int32_t msgType;
  int32_t sendStatus;
  NSString *msgId;
  NSString *from;
  NSString *to;
  GcmData *cipherData;
  NSString *ext;
  int64_t msgTime;
} ChatMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgTime",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_MsgTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, msgTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_From,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_To,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, to),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cipherData",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = ChatMessage_FieldNumber_CipherData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, cipherData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatType",
        .dataTypeSpecific.enumDescFunc = ChatType_EnumDescriptor,
        .number = ChatMessage_FieldNumber_ChatType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, chatType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_MsgType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, msgType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ext",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_Ext,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sendStatus",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_SendStatus,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, sendStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ChatMessage_ChatType_RawValue(ChatMessage *message) {
  GPBDescriptor *descriptor = [ChatMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatMessage_FieldNumber_ChatType];
  return GPBGetMessageInt32Field(message, field);
}

void SetChatMessage_ChatType_RawValue(ChatMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [ChatMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ChatMessage_FieldNumber_ChatType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - MessageData

@implementation MessageData

@dynamic hasChatMsg, chatMsg;
@dynamic hasChatSession, chatSession;

typedef struct MessageData__storage_ {
  uint32_t _has_storage_[1];
  ChatMessage *chatMsg;
  ChatSession *chatSession;
} MessageData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatMsg",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatMessage),
        .number = MessageData_FieldNumber_ChatMsg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageData__storage_, chatMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatSession",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatSession),
        .number = MessageData_FieldNumber_ChatSession,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageData__storage_, chatSession),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageData class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextMessage

@implementation TextMessage

@dynamic content;
@dynamic atAddressesArray, atAddressesArray_Count;
@dynamic snapTime;
@dynamic hasSender, sender;

typedef struct TextMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
  NSMutableArray *atAddressesArray;
  MessageUserInfo *sender;
  int64_t snapTime;
} TextMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = TextMessage_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "atAddressesArray",
        .dataTypeSpecific.className = NULL,
        .number = TextMessage_FieldNumber_AtAddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TextMessage__storage_, atAddressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snapTime",
        .dataTypeSpecific.className = NULL,
        .number = TextMessage_FieldNumber_SnapTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TextMessage__storage_, snapTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = TextMessage_FieldNumber_Sender,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TextMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionMessage

@implementation EmotionMessage

@dynamic content;
@dynamic snapTime;
@dynamic hasSender, sender;

typedef struct EmotionMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
  MessageUserInfo *sender;
  int64_t snapTime;
} EmotionMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = EmotionMessage_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snapTime",
        .dataTypeSpecific.className = NULL,
        .number = EmotionMessage_FieldNumber_SnapTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionMessage__storage_, snapTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = EmotionMessage_FieldNumber_Sender,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmotionMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhotoMessage

@implementation PhotoMessage

@dynamic URL;
@dynamic thum;
@dynamic size;
@dynamic imageWidth;
@dynamic imageHeight;
@dynamic snapTime;
@dynamic hasSender, sender;

typedef struct PhotoMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t imageWidth;
  int32_t imageHeight;
  NSString *URL;
  NSString *thum;
  NSString *size;
  MessageUserInfo *sender;
  int64_t snapTime;
} PhotoMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thum",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_Thum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, thum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageWidth",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_ImageWidth,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, imageWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageHeight",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_ImageHeight,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, imageHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "snapTime",
        .dataTypeSpecific.className = NULL,
        .number = PhotoMessage_FieldNumber_SnapTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, snapTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = PhotoMessage_FieldNumber_Sender,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PhotoMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhotoMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhotoMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceMessage

@implementation VoiceMessage

@dynamic URL;
@dynamic timeLength;
@dynamic size;
@dynamic snapTime;
@dynamic hasSender, sender;

typedef struct VoiceMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t size;
  NSString *URL;
  NSString *timeLength;
  MessageUserInfo *sender;
  int64_t snapTime;
} VoiceMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = VoiceMessage_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeLength",
        .dataTypeSpecific.className = NULL,
        .number = VoiceMessage_FieldNumber_TimeLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoiceMessage__storage_, timeLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = VoiceMessage_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VoiceMessage__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "snapTime",
        .dataTypeSpecific.className = NULL,
        .number = VoiceMessage_FieldNumber_SnapTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VoiceMessage__storage_, snapTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = VoiceMessage_FieldNumber_Sender,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VoiceMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VideoMessage

@implementation VideoMessage

@dynamic URL;
@dynamic cover;
@dynamic timeLength;
@dynamic size;
@dynamic imageWidth;
@dynamic imageHeight;
@dynamic snapTime;
@dynamic hasSender, sender;

typedef struct VideoMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t size;
  int32_t imageWidth;
  int32_t imageHeight;
  NSString *URL;
  NSString *cover;
  NSString *timeLength;
  MessageUserInfo *sender;
  int64_t snapTime;
} VideoMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cover",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_Cover,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, cover),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeLength",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_TimeLength,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, timeLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_Size,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageWidth",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_ImageWidth,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, imageWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageHeight",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_ImageHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, imageHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "snapTime",
        .dataTypeSpecific.className = NULL,
        .number = VideoMessage_FieldNumber_SnapTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, snapTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = VideoMessage_FieldNumber_Sender,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VideoMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VideoMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VideoMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CardMessage

@implementation CardMessage

@dynamic uid;
@dynamic username;
@dynamic avatar;
@dynamic hasSender, sender;

typedef struct CardMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *uid;
  NSString *username;
  NSString *avatar;
  MessageUserInfo *sender;
} CardMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = CardMessage_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CardMessage__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = CardMessage_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CardMessage__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = CardMessage_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CardMessage__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = CardMessage_FieldNumber_Sender,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CardMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CardMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CardMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DestructMessage

@implementation DestructMessage

@dynamic time;

typedef struct DestructMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t time;
} DestructMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = DestructMessage_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DestructMessage__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DestructMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DestructMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReadReceiptMessage

@implementation ReadReceiptMessage

@dynamic messageId;

typedef struct ReadReceiptMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *messageId;
} ReadReceiptMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = ReadReceiptMessage_FieldNumber_MessageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReadReceiptMessage__storage_, messageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReadReceiptMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReadReceiptMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PaymentMessage

@implementation PaymentMessage

@dynamic paymentType;
@dynamic hashId;
@dynamic amount;
@dynamic memberSize;
@dynamic tips;
@dynamic hasSender, sender;

typedef struct PaymentMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t paymentType;
  int32_t memberSize;
  NSString *hashId;
  NSString *tips;
  MessageUserInfo *sender;
  int64_t amount;
} PaymentMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentType",
        .dataTypeSpecific.className = NULL,
        .number = PaymentMessage_FieldNumber_PaymentType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, paymentType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = PaymentMessage_FieldNumber_HashId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PaymentMessage_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "memberSize",
        .dataTypeSpecific.className = NULL,
        .number = PaymentMessage_FieldNumber_MemberSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, memberSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = PaymentMessage_FieldNumber_Tips,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = PaymentMessage_FieldNumber_Sender,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PaymentMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PaymentMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PaymentMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferMessage

@implementation TransferMessage

@dynamic transferType;
@dynamic hashId;
@dynamic amount;
@dynamic tips;
@dynamic hasSender, sender;

typedef struct TransferMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t transferType;
  NSString *hashId;
  NSString *tips;
  MessageUserInfo *sender;
  int64_t amount;
} TransferMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transferType",
        .dataTypeSpecific.className = NULL,
        .number = TransferMessage_FieldNumber_TransferType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferMessage__storage_, transferType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = TransferMessage_FieldNumber_HashId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferMessage__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = TransferMessage_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferMessage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = TransferMessage_FieldNumber_Tips,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransferMessage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = TransferMessage_FieldNumber_Sender,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TransferMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LocationMessage

@implementation LocationMessage

@dynamic latitude;
@dynamic longitude;
@dynamic address;
@dynamic screenShot;
@dynamic imageWidth;
@dynamic imageHeight;
@dynamic hasSender, sender;

typedef struct LocationMessage__storage_ {
  uint32_t _has_storage_[1];
  float latitude;
  float longitude;
  int32_t imageWidth;
  int32_t imageHeight;
  NSString *address;
  NSString *screenShot;
  MessageUserInfo *sender;
} LocationMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "screenShot",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_ScreenShot,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, screenShot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageWidth",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_ImageWidth,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, imageWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageHeight",
        .dataTypeSpecific.className = NULL,
        .number = LocationMessage_FieldNumber_ImageHeight,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, imageHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = LocationMessage_FieldNumber_Sender,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LocationMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LocationMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LocationMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LuckPacketMessage

@implementation LuckPacketMessage

@dynamic hashId;
@dynamic luckyType;
@dynamic tips;
@dynamic amount;
@dynamic hasSender, sender;

typedef struct LuckPacketMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t luckyType;
  NSString *hashId;
  NSString *tips;
  MessageUserInfo *sender;
  int64_t amount;
} LuckPacketMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = LuckPacketMessage_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LuckPacketMessage__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "luckyType",
        .dataTypeSpecific.className = NULL,
        .number = LuckPacketMessage_FieldNumber_LuckyType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LuckPacketMessage__storage_, luckyType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = LuckPacketMessage_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LuckPacketMessage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = LuckPacketMessage_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LuckPacketMessage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = LuckPacketMessage_FieldNumber_Sender,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LuckPacketMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LuckPacketMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LuckPacketMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NotifyMessage

@implementation NotifyMessage

@dynamic content;

typedef struct NotifyMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
} NotifyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMessage_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NotifyMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotifyMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NotifyMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JoinGroupMessage

@implementation JoinGroupMessage

@dynamic avatar;
@dynamic groupName;
@dynamic groupId;
@dynamic token;
@dynamic hasSender, sender;

typedef struct JoinGroupMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *avatar;
  NSString *groupName;
  NSString *groupId;
  NSString *token;
  MessageUserInfo *sender;
} JoinGroupMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = JoinGroupMessage_FieldNumber_Avatar,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JoinGroupMessage__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = JoinGroupMessage_FieldNumber_GroupName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(JoinGroupMessage__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = JoinGroupMessage_FieldNumber_GroupId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(JoinGroupMessage__storage_, groupId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = JoinGroupMessage_FieldNumber_Token,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(JoinGroupMessage__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = JoinGroupMessage_FieldNumber_Sender,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(JoinGroupMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JoinGroupMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JoinGroupMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WebsiteMessage

@implementation WebsiteMessage

@dynamic URL;
@dynamic title;
@dynamic subtitle;
@dynamic img;
@dynamic hasSender, sender;

typedef struct WebsiteMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *title;
  NSString *subtitle;
  NSString *img;
  MessageUserInfo *sender;
} WebsiteMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = WebsiteMessage_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WebsiteMessage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = WebsiteMessage_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WebsiteMessage__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subtitle",
        .dataTypeSpecific.className = NULL,
        .number = WebsiteMessage_FieldNumber_Subtitle,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WebsiteMessage__storage_, subtitle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = WebsiteMessage_FieldNumber_Img,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WebsiteMessage__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageUserInfo),
        .number = WebsiteMessage_FieldNumber_Sender,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WebsiteMessage__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WebsiteMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WebsiteMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MSMessage

@implementation MSMessage

@dynamic msgId;
@dynamic body;
@dynamic category;

typedef struct MSMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  NSString *msgId;
  NSData *body;
} MSMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = MSMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MSMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = MSMessage_FieldNumber_Body,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MSMessage__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = MSMessage_FieldNumber_Category,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MSMessage__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MSMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MSMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FileData

@implementation FileData

@dynamic URL;
@dynamic token;

typedef struct FileData__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *token;
} FileData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = FileData_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FileData__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = FileData_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FileData__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FileData class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FileData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MediaFile

@implementation MediaFile

@dynamic pubKey;
@dynamic sign;
@dynamic hasCipherData, cipherData;

typedef struct MediaFile__storage_ {
  uint32_t _has_storage_[1];
  NSString *pubKey;
  NSString *sign;
  GcmData *cipherData;
} MediaFile__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = MediaFile_FieldNumber_PubKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MediaFile__storage_, pubKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = MediaFile_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MediaFile__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cipherData",
        .dataTypeSpecific.className = GPBStringifySymbol(GcmData),
        .number = MediaFile_FieldNumber_CipherData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MediaFile__storage_, cipherData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MediaFile class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MediaFile__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RichMedia

@implementation RichMedia

@dynamic thumbnail;
@dynamic entity;

typedef struct RichMedia__storage_ {
  uint32_t _has_storage_[1];
  NSData *thumbnail;
  NSData *entity;
} RichMedia__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "thumbnail",
        .dataTypeSpecific.className = NULL,
        .number = RichMedia_FieldNumber_Thumbnail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RichMedia__storage_, thumbnail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "entity",
        .dataTypeSpecific.className = NULL,
        .number = RichMedia_FieldNumber_Entity,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RichMedia__storage_, entity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RichMedia class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RichMedia__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateGroupMessage

@implementation CreateGroupMessage

@dynamic identifier;
@dynamic secretKey;

typedef struct CreateGroupMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
  NSString *secretKey;
} CreateGroupMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.className = NULL,
        .number = CreateGroupMessage_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateGroupMessage__storage_, identifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secretKey",
        .dataTypeSpecific.className = NULL,
        .number = CreateGroupMessage_FieldNumber_SecretKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateGroupMessage__storage_, secretKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateGroupMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateGroupMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RejectMessage

@implementation RejectMessage

@dynamic msgId;
@dynamic receiverAddress;
@dynamic status;
@dynamic data_p;

typedef struct RejectMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *msgId;
  NSString *receiverAddress;
  NSData *data_p;
} RejectMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = RejectMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RejectMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receiverAddress",
        .dataTypeSpecific.className = NULL,
        .number = RejectMessage_FieldNumber_ReceiverAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RejectMessage__storage_, receiverAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = RejectMessage_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RejectMessage__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = RejectMessage_FieldNumber_Data_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RejectMessage__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RejectMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RejectMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManageSession

@implementation ManageSession

@dynamic address;

typedef struct ManageSession__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} ManageSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = ManageSession_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManageSession__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManageSession class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManageSession__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateSession

@implementation UpdateSession

@dynamic address;
@dynamic flag;

typedef struct UpdateSession__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
} UpdateSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = UpdateSession_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateSession__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = UpdateSession_FieldNumber_Flag,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateSession class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateSession__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProducerMsgDetail

@implementation ProducerMsgDetail

@dynamic type;
@dynamic ext;
@dynamic data_p;

typedef struct ProducerMsgDetail__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t ext;
  NSData *data_p;
} ProducerMsgDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ProducerMsgDetail_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProducerMsgDetail__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ext",
        .dataTypeSpecific.className = NULL,
        .number = ProducerMsgDetail_FieldNumber_Ext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProducerMsgDetail__storage_, ext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = ProducerMsgDetail_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProducerMsgDetail__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProducerMsgDetail class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProducerMsgDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMsg

@implementation OfflineMsg

@dynamic msgId;
@dynamic hasBody, body;

typedef struct OfflineMsg__storage_ {
  uint32_t _has_storage_[1];
  NSString *msgId;
  ProducerMsgDetail *body;
} OfflineMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMsg_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OfflineMsg__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = GPBStringifySymbol(ProducerMsgDetail),
        .number = OfflineMsg_FieldNumber_Body,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OfflineMsg__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMsg class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OfflineMsgs

@implementation OfflineMsgs

@dynamic offlineMsgsArray, offlineMsgsArray_Count;
@dynamic completed;

typedef struct OfflineMsgs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *offlineMsgsArray;
} OfflineMsgs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "offlineMsgsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(OfflineMsg),
        .number = OfflineMsgs_FieldNumber_OfflineMsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OfflineMsgs__storage_, offlineMsgsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "completed",
        .dataTypeSpecific.className = NULL,
        .number = OfflineMsgs_FieldNumber_Completed,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OfflineMsgs class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OfflineMsgs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000offlineMsgs\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NoticeMessage

@implementation NoticeMessage

@dynamic category;
@dynamic body;
@dynamic msgId;

typedef struct NoticeMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  NSData *body;
  NSString *msgId;
} NoticeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = NoticeMessage_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NoticeMessage__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "body",
        .dataTypeSpecific.className = NULL,
        .number = NoticeMessage_FieldNumber_Body,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NoticeMessage__storage_, body),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = NoticeMessage_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NoticeMessage__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NoticeMessage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NoticeMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Input

@implementation Input

@dynamic prevAddressesArray, prevAddressesArray_Count;
@dynamic prevValue;

typedef struct Input__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *prevAddressesArray;
  uint64_t prevValue;
} Input__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "prevAddressesArray",
        .dataTypeSpecific.className = NULL,
        .number = Input_FieldNumber_PrevAddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Input__storage_, prevAddressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "prevValue",
        .dataTypeSpecific.className = NULL,
        .number = Input_FieldNumber_PrevValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Input__storage_, prevValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Input class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Input__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Output

@implementation Output

@dynamic addressesArray, addressesArray_Count;
@dynamic value;

typedef struct Output__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
  uint64_t value;
} Output__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = Output_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Output__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = Output_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Output__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Output class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Output__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction

@implementation Transaction

@dynamic hash_p;
@dynamic blockHeight;
@dynamic createdAt;
@dynamic fee;
@dynamic inputsValue;
@dynamic category;
@dynamic balance;
@dynamic userInfosArray, userInfosArray_Count;
@dynamic inputsArray, inputsArray_Count;
@dynamic outputsArray, outputsArray_Count;
@dynamic confirmations;
@dynamic txType;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  int32_t txType;
  NSString *hash_p;
  NSString *category;
  NSMutableArray *userInfosArray;
  NSMutableArray *inputsArray;
  NSMutableArray *outputsArray;
  uint64_t blockHeight;
  uint64_t createdAt;
  uint64_t fee;
  uint64_t inputsValue;
  int64_t balance;
  uint64_t confirmations;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blockHeight",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_BlockHeight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction__storage_, blockHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_CreatedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Fee,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "inputsValue",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_InputsValue,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction__storage_, inputsValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Category,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Balance,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userInfosArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfoBalance),
        .number = Transaction_FieldNumber_UserInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, userInfosArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Input),
        .number = Transaction_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Output),
        .number = Transaction_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confirmations",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_Confirmations,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Transaction__storage_, confirmations),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "txType",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_TxType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Transaction__storage_, txType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\000userInfos\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressBook

@implementation AddressBook

@dynamic addressInfoArray, addressInfoArray_Count;

typedef struct AddressBook__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressInfoArray;
} AddressBook__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AddressBook_AddressInfo),
        .number = AddressBook_FieldNumber_AddressInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddressBook__storage_, addressInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressBook class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressBook__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddressBook_AddressInfo

@implementation AddressBook_AddressInfo

@dynamic address;
@dynamic tag;

typedef struct AddressBook_AddressInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *tag;
} AddressBook_AddressInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AddressBook_AddressInfo_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddressBook_AddressInfo__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag",
        .dataTypeSpecific.className = NULL,
        .number = AddressBook_AddressInfo_FieldNumber_Tag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddressBook_AddressInfo__storage_, tag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddressBook_AddressInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddressBook_AddressInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(AddressBook)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Bill

@implementation Bill

@dynamic hash_p;
@dynamic sender;
@dynamic receiver;
@dynamic amount;
@dynamic txid;
@dynamic status;
@dynamic tips;
@dynamic createdAt;

typedef struct Bill__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *hash_p;
  NSString *sender;
  NSString *receiver;
  NSString *txid;
  NSString *tips;
  uint64_t amount;
  int64_t createdAt;
} Bill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = Bill_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Bill__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = Bill_FieldNumber_Sender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Bill__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receiver",
        .dataTypeSpecific.className = NULL,
        .number = Bill_FieldNumber_Receiver,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Bill__storage_, receiver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = Bill_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Bill__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = Bill_FieldNumber_Txid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Bill__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = Bill_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Bill__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = Bill_FieldNumber_Tips,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Bill__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = Bill_FieldNumber_CreatedAt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Bill__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Bill class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Bill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BillHashId

@implementation BillHashId

@dynamic hash_p;

typedef struct BillHashId__storage_ {
  uint32_t _has_storage_[1];
  NSString *hash_p;
} BillHashId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = BillHashId_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BillHashId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BillHashId class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BillHashId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendBill

@implementation SendBill

@dynamic receiver;
@dynamic amount;
@dynamic tips;

typedef struct SendBill__storage_ {
  uint32_t _has_storage_[1];
  NSString *receiver;
  NSString *tips;
  uint64_t amount;
} SendBill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "receiver",
        .dataTypeSpecific.className = NULL,
        .number = SendBill_FieldNumber_Receiver,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendBill__storage_, receiver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = SendBill_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendBill__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = SendBill_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendBill__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendBill class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendBill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReceiveBill

@implementation ReceiveBill

@dynamic sender;
@dynamic amount;
@dynamic tips;

typedef struct ReceiveBill__storage_ {
  uint32_t _has_storage_[1];
  NSString *sender;
  NSString *tips;
  uint64_t amount;
} ReceiveBill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = ReceiveBill_FieldNumber_Sender,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReceiveBill__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = ReceiveBill_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReceiveBill__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = ReceiveBill_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReceiveBill__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReceiveBill class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceiveBill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PublishTx

@implementation PublishTx

@dynamic hash_p;
@dynamic rawTx;

typedef struct PublishTx__storage_ {
  uint32_t _has_storage_[1];
  NSString *hash_p;
  NSString *rawTx;
} PublishTx__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = PublishTx_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PublishTx__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rawTx",
        .dataTypeSpecific.className = NULL,
        .number = PublishTx_FieldNumber_RawTx,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PublishTx__storage_, rawTx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PublishTx class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PublishTx__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MuiltSendBill

@implementation MuiltSendBill

@dynamic addressesArray, addressesArray_Count;
@dynamic amount;
@dynamic tips;
@dynamic txData;

typedef struct MuiltSendBill__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
  NSString *tips;
  NSString *txData;
  uint64_t amount;
} MuiltSendBill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = MuiltSendBill_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MuiltSendBill__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = MuiltSendBill_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MuiltSendBill__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = MuiltSendBill_FieldNumber_Tips,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MuiltSendBill__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txData",
        .dataTypeSpecific.className = NULL,
        .number = MuiltSendBill_FieldNumber_TxData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MuiltSendBill__storage_, txData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MuiltSendBill class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MuiltSendBill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MuiltSendBillResp

@implementation MuiltSendBillResp

@dynamic billsArray, billsArray_Count;

typedef struct MuiltSendBillResp__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *billsArray;
} MuiltSendBillResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "billsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Bill),
        .number = MuiltSendBillResp_FieldNumber_BillsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MuiltSendBillResp__storage_, billsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MuiltSendBillResp class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MuiltSendBillResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Unspent

@implementation Unspent

@dynamic txHash;
@dynamic txOutputN;
@dynamic txOutputN2;
@dynamic value;
@dynamic confirmations;
@dynamic scriptpubkey;
@dynamic priority;

typedef struct Unspent__storage_ {
  uint32_t _has_storage_[1];
  int32_t txOutputN;
  int32_t txOutputN2;
  int32_t confirmations;
  int32_t priority;
  NSString *txHash;
  NSString *scriptpubkey;
  uint64_t value;
} Unspent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txHash",
        .dataTypeSpecific.className = NULL,
        .number = Unspent_FieldNumber_TxHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Unspent__storage_, txHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txOutputN",
        .dataTypeSpecific.className = NULL,
        .number = Unspent_FieldNumber_TxOutputN,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Unspent__storage_, txOutputN),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "txOutputN2",
        .dataTypeSpecific.className = NULL,
        .number = Unspent_FieldNumber_TxOutputN2,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Unspent__storage_, txOutputN2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = Unspent_FieldNumber_Value,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Unspent__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "confirmations",
        .dataTypeSpecific.className = NULL,
        .number = Unspent_FieldNumber_Confirmations,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Unspent__storage_, confirmations),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "scriptpubkey",
        .dataTypeSpecific.className = NULL,
        .number = Unspent_FieldNumber_Scriptpubkey,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Unspent__storage_, scriptpubkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priority",
        .dataTypeSpecific.className = NULL,
        .number = Unspent_FieldNumber_Priority,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Unspent__storage_, priority),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Unspent class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Unspent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Unspents

@implementation Unspents

@dynamic unspentsArray, unspentsArray_Count;

typedef struct Unspents__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *unspentsArray;
} Unspents__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unspentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Unspent),
        .number = Unspents_FieldNumber_UnspentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Unspents__storage_, unspentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Unspents class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Unspents__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transactions

@implementation Transactions

@dynamic transactionsArray, transactionsArray_Count;

typedef struct Transactions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} Transactions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = Transactions_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transactions__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transactions class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transactions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Compose

@implementation Compose

@dynamic unspentsArray, unspentsArray_Count;
@dynamic address;

typedef struct Compose__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *unspentsArray;
  NSString *address;
} Compose__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unspentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Unspent),
        .number = Compose_FieldNumber_UnspentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Compose__storage_, unspentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Compose_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Compose__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Compose class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Compose__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Composes

@implementation Composes

@dynamic composesArray, composesArray_Count;
@dynamic estimateFee;

typedef struct Composes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *composesArray;
  uint64_t estimateFee;
} Composes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "composesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Compose),
        .number = Composes_FieldNumber_ComposesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Composes__storage_, composesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "estimateFee",
        .dataTypeSpecific.className = NULL,
        .number = Composes_FieldNumber_EstimateFee,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Composes__storage_, estimateFee),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Composes class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Composes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OrdinaryRedPackage

@implementation OrdinaryRedPackage

@dynamic hashId;
@dynamic category;
@dynamic size;
@dynamic money;
@dynamic reciverIdentifier;
@dynamic tips;
@dynamic rawTx;
@dynamic type;

typedef struct OrdinaryRedPackage__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  int32_t size;
  int32_t type;
  NSString *hashId;
  NSString *reciverIdentifier;
  NSString *tips;
  NSString *rawTx;
  int64_t money;
} OrdinaryRedPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryRedPackage_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OrdinaryRedPackage__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryRedPackage_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OrdinaryRedPackage__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryRedPackage_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OrdinaryRedPackage__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "money",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryRedPackage_FieldNumber_Money,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OrdinaryRedPackage__storage_, money),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "reciverIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryRedPackage_FieldNumber_ReciverIdentifier,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OrdinaryRedPackage__storage_, reciverIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryRedPackage_FieldNumber_Tips,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OrdinaryRedPackage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rawTx",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryRedPackage_FieldNumber_RawTx,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OrdinaryRedPackage__storage_, rawTx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryRedPackage_FieldNumber_Type,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OrdinaryRedPackage__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OrdinaryRedPackage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OrdinaryRedPackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedPackage

@implementation RedPackage

@dynamic hashId;
@dynamic sendAddress;
@dynamic category;
@dynamic size;
@dynamic money;
@dynamic tips;
@dynamic sendTx;
@dynamic status;
@dynamic txid;
@dynamic remainSize;
@dynamic refund;
@dynamic expired;
@dynamic URL;
@dynamic deadline;
@dynamic typ;
@dynamic createdAt;
@dynamic system;
@dynamic pause;
@dynamic currency;

typedef struct RedPackage__storage_ {
  uint32_t _has_storage_[1];
  int32_t category;
  int32_t size;
  int32_t status;
  int32_t typ;
  int32_t currency;
  NSString *hashId;
  NSString *sendAddress;
  NSString *tips;
  NSString *sendTx;
  NSString *txid;
  NSString *URL;
  int64_t money;
  int64_t remainSize;
  int64_t deadline;
  int64_t createdAt;
} RedPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedPackage__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sendAddress",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_SendAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedPackage__storage_, sendAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Category,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedPackage__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Size,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedPackage__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "money",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Money,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedPackage__storage_, money),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Tips,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedPackage__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sendTx",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_SendTx,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedPackage__storage_, sendTx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Status,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RedPackage__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Txid,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RedPackage__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remainSize",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_RemainSize,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RedPackage__storage_, remainSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "refund",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Refund,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "expired",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Expired,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_URL,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(RedPackage__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deadline",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Deadline,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(RedPackage__storage_, deadline),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "typ",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Typ,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(RedPackage__storage_, typ),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_CreatedAt,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(RedPackage__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "system",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_System,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pause",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Pause,
        .hasIndex = 20,
        .offset = 21,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = RedPackage_FieldNumber_Currency,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(RedPackage__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedPackage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedPackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\r!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedPackageInfo

@implementation RedPackageInfo

@dynamic hasRedpackage, redpackage;
@dynamic gradHistoryArray, gradHistoryArray_Count;

typedef struct RedPackageInfo__storage_ {
  uint32_t _has_storage_[1];
  RedPackage *redpackage;
  NSMutableArray *gradHistoryArray;
} RedPackageInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redpackage",
        .dataTypeSpecific.className = GPBStringifySymbol(RedPackage),
        .number = RedPackageInfo_FieldNumber_Redpackage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedPackageInfo__storage_, redpackage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gradHistoryArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GradRedPackageHistroy),
        .number = RedPackageInfo_FieldNumber_GradHistoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedPackageInfo__storage_, gradHistoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedPackageInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedPackageInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedPackageHash

@implementation RedPackageHash

@dynamic id_p;

typedef struct RedPackageHash__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
} RedPackageHash__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = RedPackageHash_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedPackageHash__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedPackageHash class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedPackageHash__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingRedPackage

@implementation PendingRedPackage

@dynamic address;
@dynamic hashId;

typedef struct PendingRedPackage__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *hashId;
} PendingRedPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = PendingRedPackage_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingRedPackage__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = PendingRedPackage_FieldNumber_HashId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingRedPackage__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingRedPackage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingRedPackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GrabRedPackageResp

@implementation GrabRedPackageResp

@dynamic status;

typedef struct GrabRedPackageResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} GrabRedPackageResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GrabRedPackageResp_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GrabRedPackageResp__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GrabRedPackageResp class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GrabRedPackageResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GradRedPackageHistroy

@implementation GradRedPackageHistroy

@dynamic amount;
@dynamic hasUserinfo, userinfo;
@dynamic createdAt;

typedef struct GradRedPackageHistroy__storage_ {
  uint32_t _has_storage_[1];
  UserInfo *userinfo;
  int64_t amount;
  int64_t createdAt;
} GradRedPackageHistroy__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = GradRedPackageHistroy_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GradRedPackageHistroy__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "userinfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = GradRedPackageHistroy_FieldNumber_Userinfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GradRedPackageHistroy__storage_, userinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = GradRedPackageHistroy_FieldNumber_CreatedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GradRedPackageHistroy__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GradRedPackageHistroy class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GradRedPackageHistroy__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LaunchCrowdfunding

@implementation LaunchCrowdfunding

@dynamic groupHash;
@dynamic size;
@dynamic total;
@dynamic tips;

typedef struct LaunchCrowdfunding__storage_ {
  uint32_t _has_storage_[1];
  NSString *groupHash;
  NSString *tips;
  int64_t size;
  int64_t total;
} LaunchCrowdfunding__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupHash",
        .dataTypeSpecific.className = NULL,
        .number = LaunchCrowdfunding_FieldNumber_GroupHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LaunchCrowdfunding__storage_, groupHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = LaunchCrowdfunding_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LaunchCrowdfunding__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = LaunchCrowdfunding_FieldNumber_Total,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LaunchCrowdfunding__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = LaunchCrowdfunding_FieldNumber_Tips,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LaunchCrowdfunding__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LaunchCrowdfunding class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LaunchCrowdfunding__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PayCrowdfunding

@implementation PayCrowdfunding

@dynamic hashId;
@dynamic amount;
@dynamic rawTx;

typedef struct PayCrowdfunding__storage_ {
  uint32_t _has_storage_[1];
  NSString *hashId;
  NSString *rawTx;
  int64_t amount;
} PayCrowdfunding__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = PayCrowdfunding_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PayCrowdfunding__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = PayCrowdfunding_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PayCrowdfunding__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "rawTx",
        .dataTypeSpecific.className = NULL,
        .number = PayCrowdfunding_FieldNumber_RawTx,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PayCrowdfunding__storage_, rawTx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PayCrowdfunding class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PayCrowdfunding__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CrowdfundingIdentifier

@implementation CrowdfundingIdentifier

@dynamic hashId;

typedef struct CrowdfundingIdentifier__storage_ {
  uint32_t _has_storage_[1];
  NSString *hashId;
} CrowdfundingIdentifier__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingIdentifier_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CrowdfundingIdentifier__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CrowdfundingIdentifier class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CrowdfundingIdentifier__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Crowdfunding

@implementation Crowdfunding

@dynamic hashId;
@dynamic hasSender, sender;
@dynamic size;
@dynamic total;
@dynamic tips;
@dynamic status;
@dynamic hasRecords, records;
@dynamic createdAt;
@dynamic remainSize;
@dynamic groupName;

typedef struct Crowdfunding__storage_ {
  uint32_t _has_storage_[1];
  NSString *hashId;
  UserInfo *sender;
  NSString *tips;
  CrowdfundingRecords *records;
  NSString *groupName;
  int64_t size;
  int64_t total;
  int64_t status;
  int64_t createdAt;
  int64_t remainSize;
} Crowdfunding__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = Crowdfunding_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Crowdfunding__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = Crowdfunding_FieldNumber_Sender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Crowdfunding__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = Crowdfunding_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Crowdfunding__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = Crowdfunding_FieldNumber_Total,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Crowdfunding__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = Crowdfunding_FieldNumber_Tips,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Crowdfunding__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = Crowdfunding_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Crowdfunding__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "records",
        .dataTypeSpecific.className = GPBStringifySymbol(CrowdfundingRecords),
        .number = Crowdfunding_FieldNumber_Records,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Crowdfunding__storage_, records),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = Crowdfunding_FieldNumber_CreatedAt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Crowdfunding__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remainSize",
        .dataTypeSpecific.className = NULL,
        .number = Crowdfunding_FieldNumber_RemainSize,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Crowdfunding__storage_, remainSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "groupName",
        .dataTypeSpecific.className = NULL,
        .number = Crowdfunding_FieldNumber_GroupName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Crowdfunding__storage_, groupName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Crowdfunding class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Crowdfunding__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Crowdfundings

@implementation Crowdfundings

@dynamic listArray, listArray_Count;
@dynamic count;

typedef struct Crowdfundings__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
  int64_t count;
} Crowdfundings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Crowdfunding),
        .number = Crowdfundings_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Crowdfundings__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = Crowdfundings_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Crowdfundings__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Crowdfundings class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Crowdfundings__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserCrowdfundingInfo

@implementation UserCrowdfundingInfo

@dynamic pageSize;
@dynamic pageIndex;

typedef struct UserCrowdfundingInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  int32_t pageIndex;
} UserCrowdfundingInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = UserCrowdfundingInfo_FieldNumber_PageSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserCrowdfundingInfo__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageIndex",
        .dataTypeSpecific.className = NULL,
        .number = UserCrowdfundingInfo_FieldNumber_PageIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserCrowdfundingInfo__storage_, pageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserCrowdfundingInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserCrowdfundingInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CrowdfundingInfo

@implementation CrowdfundingInfo

@dynamic hashId;
@dynamic pageSize;
@dynamic pageIndex;

typedef struct CrowdfundingInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *hashId;
  NSString *pageSize;
  NSString *pageIndex;
} CrowdfundingInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingInfo_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CrowdfundingInfo__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingInfo_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CrowdfundingInfo__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageIndex",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingInfo_FieldNumber_PageIndex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CrowdfundingInfo__storage_, pageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CrowdfundingInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CrowdfundingInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\010\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CrowdfundingRecord

@implementation CrowdfundingRecord

@dynamic hasUser, user;
@dynamic amount;
@dynamic txid;
@dynamic status;
@dynamic createdAt;

typedef struct CrowdfundingRecord__storage_ {
  uint32_t _has_storage_[1];
  UserInfo *user;
  NSString *txid;
  int64_t amount;
  int64_t status;
  uint64_t createdAt;
} CrowdfundingRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = CrowdfundingRecord_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CrowdfundingRecord__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingRecord_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CrowdfundingRecord__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingRecord_FieldNumber_Txid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CrowdfundingRecord__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingRecord_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CrowdfundingRecord__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingRecord_FieldNumber_CreatedAt,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CrowdfundingRecord__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CrowdfundingRecord class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CrowdfundingRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CrowdfundingRecords

@implementation CrowdfundingRecords

@dynamic listArray, listArray_Count;
@dynamic count;

typedef struct CrowdfundingRecords__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *listArray;
  int64_t count;
} CrowdfundingRecords__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CrowdfundingRecord),
        .number = CrowdfundingRecords_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CrowdfundingRecords__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingRecords_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CrowdfundingRecords__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CrowdfundingRecords class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CrowdfundingRecords__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferNotice

@implementation TransferNotice

@dynamic hashId;
@dynamic hasSender, sender;
@dynamic hasReceiver, receiver;
@dynamic amount;
@dynamic txId;
@dynamic status;
@dynamic tips;
@dynamic createdAt;

typedef struct TransferNotice__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *hashId;
  UserInfo *sender;
  UserInfo *receiver;
  NSString *txId;
  NSString *tips;
  int64_t amount;
  int64_t createdAt;
} TransferNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = TransferNotice_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferNotice__storage_, hashId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = TransferNotice_FieldNumber_Sender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferNotice__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receiver",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = TransferNotice_FieldNumber_Receiver,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferNotice__storage_, receiver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = TransferNotice_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransferNotice__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txId",
        .dataTypeSpecific.className = NULL,
        .number = TransferNotice_FieldNumber_TxId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TransferNotice__storage_, txId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = TransferNotice_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TransferNotice__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = TransferNotice_FieldNumber_Tips,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TransferNotice__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = TransferNotice_FieldNumber_CreatedAt,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TransferNotice__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferNotice class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\005\004\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedPackageNotice

@implementation RedPackageNotice

@dynamic hashId;
@dynamic sender;
@dynamic receiver;
@dynamic identifer;
@dynamic category;

typedef struct RedPackageNotice__storage_ {
  uint32_t _has_storage_[1];
  NSString *hashId;
  NSString *sender;
  NSString *receiver;
  NSString *identifer;
  int64_t category;
} RedPackageNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = RedPackageNotice_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedPackageNotice__storage_, hashId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = RedPackageNotice_FieldNumber_Sender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedPackageNotice__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receiver",
        .dataTypeSpecific.className = NULL,
        .number = RedPackageNotice_FieldNumber_Receiver,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedPackageNotice__storage_, receiver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "identifer",
        .dataTypeSpecific.className = NULL,
        .number = RedPackageNotice_FieldNumber_Identifer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedPackageNotice__storage_, identifer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = RedPackageNotice_FieldNumber_Category,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedPackageNotice__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedPackageNotice class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedPackageNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionNotice

@implementation TransactionNotice

@dynamic hashId;
@dynamic status;
@dynamic identifer;

typedef struct TransactionNotice__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *hashId;
  NSString *identifer;
} TransactionNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = TransactionNotice_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionNotice__storage_, hashId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = TransactionNotice_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionNotice__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "identifer",
        .dataTypeSpecific.className = NULL,
        .number = TransactionNotice_FieldNumber_Identifer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransactionNotice__storage_, identifer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionNotice class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BillNotice

@implementation BillNotice

@dynamic hashId;
@dynamic status;
@dynamic sender;
@dynamic receiver;
@dynamic amount;
@dynamic groupId;

typedef struct BillNotice__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *hashId;
  NSString *sender;
  NSString *receiver;
  NSString *groupId;
  uint64_t amount;
} BillNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = BillNotice_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BillNotice__storage_, hashId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = BillNotice_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BillNotice__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = BillNotice_FieldNumber_Sender,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BillNotice__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receiver",
        .dataTypeSpecific.className = NULL,
        .number = BillNotice_FieldNumber_Receiver,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BillNotice__storage_, receiver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = BillNotice_FieldNumber_Amount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BillNotice__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = BillNotice_FieldNumber_GroupId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BillNotice__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BillNotice class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BillNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\006\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CrowdfundingNotice

@implementation CrowdfundingNotice

@dynamic hashId;
@dynamic status;
@dynamic sender;
@dynamic receiver;
@dynamic amount;
@dynamic groupId;
@dynamic hasCrowdfunding, crowdfunding;

typedef struct CrowdfundingNotice__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *hashId;
  NSString *sender;
  NSString *receiver;
  NSString *groupId;
  Crowdfunding *crowdfunding;
  uint64_t amount;
} CrowdfundingNotice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingNotice_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CrowdfundingNotice__storage_, hashId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingNotice_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CrowdfundingNotice__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingNotice_FieldNumber_Sender,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CrowdfundingNotice__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receiver",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingNotice_FieldNumber_Receiver,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CrowdfundingNotice__storage_, receiver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingNotice_FieldNumber_Amount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CrowdfundingNotice__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = CrowdfundingNotice_FieldNumber_GroupId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CrowdfundingNotice__storage_, groupId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "crowdfunding",
        .dataTypeSpecific.className = GPBStringifySymbol(Crowdfunding),
        .number = CrowdfundingNotice_FieldNumber_Crowdfunding,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CrowdfundingNotice__storage_, crowdfunding),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CrowdfundingNotice class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CrowdfundingNotice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\006\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OrdinaryBilling

@implementation OrdinaryBilling

@dynamic hashId;
@dynamic money;
@dynamic tips;
@dynamic rawTx;

typedef struct OrdinaryBilling__storage_ {
  uint32_t _has_storage_[1];
  NSString *hashId;
  NSString *tips;
  NSString *rawTx;
  uint64_t money;
} OrdinaryBilling__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryBilling_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OrdinaryBilling__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "money",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryBilling_FieldNumber_Money,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OrdinaryBilling__storage_, money),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryBilling_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OrdinaryBilling__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rawTx",
        .dataTypeSpecific.className = NULL,
        .number = OrdinaryBilling_FieldNumber_RawTx,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OrdinaryBilling__storage_, rawTx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OrdinaryBilling class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OrdinaryBilling__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExternalBilling

@implementation ExternalBilling

@dynamic URL;

typedef struct ExternalBilling__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
} ExternalBilling__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBilling_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExternalBilling__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExternalBilling class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExternalBilling__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExternalBillingToken

@implementation ExternalBillingToken

@dynamic token;

typedef struct ExternalBillingToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} ExternalBillingToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExternalBillingToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExternalBillingToken class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExternalBillingToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedPackageToken

@implementation RedPackageToken

@dynamic token;

typedef struct RedPackageToken__storage_ {
  uint32_t _has_storage_[1];
  NSString *token;
} RedPackageToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = RedPackageToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedPackageToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedPackageToken class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedPackageToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExternalBillingHistory

@implementation ExternalBillingHistory

@dynamic pageSize;
@dynamic pageIndex;

typedef struct ExternalBillingHistory__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  int32_t pageIndex;
} ExternalBillingHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingHistory_FieldNumber_PageSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExternalBillingHistory__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageIndex",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingHistory_FieldNumber_PageIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExternalBillingHistory__storage_, pageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExternalBillingHistory class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExternalBillingHistory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExternalBillingInfo

@implementation ExternalBillingInfo

@dynamic hash_p;
@dynamic sender;
@dynamic receiver;
@dynamic amount;
@dynamic txid;
@dynamic status;
@dynamic tips;
@dynamic received;
@dynamic publish;
@dynamic refund;
@dynamic expired;
@dynamic createdAt;
@dynamic URL;
@dynamic hasReceiverInfo, receiverInfo;
@dynamic deadline;
@dynamic cancelled;
@dynamic currency;

typedef struct ExternalBillingInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  int32_t currency;
  NSString *hash_p;
  NSString *sender;
  NSString *receiver;
  NSString *txid;
  NSString *tips;
  NSString *URL;
  UserInfo *receiverInfo;
  uint64_t amount;
  int64_t createdAt;
  int64_t deadline;
} ExternalBillingInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Sender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receiver",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Receiver,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, receiver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Amount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "txid",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Txid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, txid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Tips,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "received",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Received,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "publish",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Publish,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "refund",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Refund,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "expired",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Expired,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_CreatedAt,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, createdAt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_URL,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "receiverInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = ExternalBillingInfo_FieldNumber_ReceiverInfo,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, receiverInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deadline",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Deadline,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, deadline),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cancelled",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Cancelled,
        .hasIndex = 19,
        .offset = 20,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfo_FieldNumber_Currency,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ExternalBillingInfo__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExternalBillingInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExternalBillingInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\r!!!\000\016\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExternalBillingInfos

@implementation ExternalBillingInfos

@dynamic externalBillingInfosArray, externalBillingInfosArray_Count;
@dynamic count;

typedef struct ExternalBillingInfos__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *externalBillingInfosArray;
  int64_t count;
} ExternalBillingInfos__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "externalBillingInfosArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ExternalBillingInfo),
        .number = ExternalBillingInfos_FieldNumber_ExternalBillingInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ExternalBillingInfos__storage_, externalBillingInfosArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = ExternalBillingInfos_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExternalBillingInfos__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExternalBillingInfos class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExternalBillingInfos__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000externalBillingInfos\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PendingPackage

@implementation PendingPackage

@dynamic address;
@dynamic hashId;

typedef struct PendingPackage__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  NSString *hashId;
} PendingPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = PendingPackage_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PendingPackage__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = PendingPackage_FieldNumber_HashId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PendingPackage__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PendingPackage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PendingPackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - History

@implementation History

@dynamic pageSize;
@dynamic pageIndex;

typedef struct History__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  int32_t pageIndex;
} History__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = History_FieldNumber_PageSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(History__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageIndex",
        .dataTypeSpecific.className = NULL,
        .number = History_FieldNumber_PageIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(History__storage_, pageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[History class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(History__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedPackages

@implementation RedPackages

@dynamic redPackagesArray, redPackagesArray_Count;
@dynamic count;

typedef struct RedPackages__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *redPackagesArray;
  int64_t count;
} RedPackages__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redPackagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RedPackage),
        .number = RedPackages_FieldNumber_RedPackagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedPackages__storage_, redPackagesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = RedPackages_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedPackages__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedPackages class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedPackages__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000redPackages\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedPackageInfos

@implementation RedPackageInfos

@dynamic redPackageInfosArray, redPackageInfosArray_Count;
@dynamic count;

typedef struct RedPackageInfos__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *redPackageInfosArray;
  int64_t count;
} RedPackageInfos__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redPackageInfosArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RedPackageInfo),
        .number = RedPackageInfos_FieldNumber_RedPackageInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedPackageInfos__storage_, redPackageInfosArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = RedPackageInfos_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedPackageInfos__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedPackageInfos class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedPackageInfos__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000redPackageInfos\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExternalRedPackageInfo

@implementation ExternalRedPackageInfo

@dynamic hashId;
@dynamic hasSender, sender;
@dynamic tips;
@dynamic msgId;
@dynamic system;

typedef struct ExternalRedPackageInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *hashId;
  UserInfo *sender;
  NSString *tips;
  NSString *msgId;
} ExternalRedPackageInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashId",
        .dataTypeSpecific.className = NULL,
        .number = ExternalRedPackageInfo_FieldNumber_HashId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExternalRedPackageInfo__storage_, hashId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = ExternalRedPackageInfo_FieldNumber_Sender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExternalRedPackageInfo__storage_, sender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tips",
        .dataTypeSpecific.className = NULL,
        .number = ExternalRedPackageInfo_FieldNumber_Tips,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExternalRedPackageInfo__storage_, tips),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = ExternalRedPackageInfo_FieldNumber_MsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ExternalRedPackageInfo__storage_, msgId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "system",
        .dataTypeSpecific.className = NULL,
        .number = ExternalRedPackageInfo_FieldNumber_System,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExternalRedPackageInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExternalRedPackageInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnspentOrder

@implementation UnspentOrder

@dynamic amount;
@dynamic sendToLength;
@dynamic fee;

typedef struct UnspentOrder__storage_ {
  uint32_t _has_storage_[1];
  int32_t sendToLength;
  int64_t amount;
  int64_t fee;
} UnspentOrder__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = UnspentOrder_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnspentOrder__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sendToLength",
        .dataTypeSpecific.className = NULL,
        .number = UnspentOrder_FieldNumber_SendToLength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnspentOrder__storage_, sendToLength),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = UnspentOrder_FieldNumber_Fee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnspentOrder__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnspentOrder class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnspentOrder__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnspentAmount

@implementation UnspentAmount

@dynamic amount;
@dynamic avaliableAmount;

typedef struct UnspentAmount__storage_ {
  uint32_t _has_storage_[1];
  int64_t amount;
  int64_t avaliableAmount;
} UnspentAmount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = UnspentAmount_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnspentAmount__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "avaliableAmount",
        .dataTypeSpecific.className = NULL,
        .number = UnspentAmount_FieldNumber_AvaliableAmount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnspentAmount__storage_, avaliableAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnspentAmount class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnspentAmount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnspentOrderResponse

@implementation UnspentOrderResponse

@dynamic unspentsArray, unspentsArray_Count;
@dynamic completed;
@dynamic amount;
@dynamic package;
@dynamic dust;
@dynamic fee;
@dynamic unspentAmount;

typedef struct UnspentOrderResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *unspentsArray;
  int64_t amount;
  int64_t fee;
  int64_t unspentAmount;
} UnspentOrderResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unspentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Unspent),
        .number = UnspentOrderResponse_FieldNumber_UnspentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnspentOrderResponse__storage_, unspentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "completed",
        .dataTypeSpecific.className = NULL,
        .number = UnspentOrderResponse_FieldNumber_Completed,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = UnspentOrderResponse_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnspentOrderResponse__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "package",
        .dataTypeSpecific.className = NULL,
        .number = UnspentOrderResponse_FieldNumber_Package,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dust",
        .dataTypeSpecific.className = NULL,
        .number = UnspentOrderResponse_FieldNumber_Dust,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = UnspentOrderResponse_FieldNumber_Fee,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UnspentOrderResponse__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unspentAmount",
        .dataTypeSpecific.className = NULL,
        .number = UnspentOrderResponse_FieldNumber_UnspentAmount,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UnspentOrderResponse__storage_, unspentAmount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnspentOrderResponse class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnspentOrderResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\007\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PayPin

@implementation PayPin

@dynamic payPin;

typedef struct PayPin__storage_ {
  uint32_t _has_storage_[1];
  NSString *payPin;
} PayPin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "payPin",
        .dataTypeSpecific.className = NULL,
        .number = PayPin_FieldNumber_PayPin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PayPin__storage_, payPin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PayPin class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PayPin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PayPinVersion

@implementation PayPinVersion

@dynamic version;

typedef struct PayPinVersion__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
} PayPinVersion__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PayPinVersion_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PayPinVersion__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PayPinVersion class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PayPinVersion__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncBadge

@implementation SyncBadge

@dynamic badge;

typedef struct SyncBadge__storage_ {
  uint32_t _has_storage_[1];
  int32_t badge;
} SyncBadge__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "badge",
        .dataTypeSpecific.className = NULL,
        .number = SyncBadge_FieldNumber_Badge,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncBadge__storage_, badge),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncBadge class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncBadge__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AppInfo

@implementation AppInfo

@dynamic version;
@dynamic platform;
@dynamic osVersion;
@dynamic model;

typedef struct AppInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  NSString *platform;
  NSString *osVersion;
  NSString *model;
} AppInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = AppInfo_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppInfo__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "platform",
        .dataTypeSpecific.className = NULL,
        .number = AppInfo_FieldNumber_Platform,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppInfo__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "osVersion",
        .dataTypeSpecific.className = NULL,
        .number = AppInfo_FieldNumber_OsVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AppInfo__storage_, osVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = AppInfo_FieldNumber_Model,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AppInfo__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppInfo class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExoprtPrivkeyQrcode

@implementation ExoprtPrivkeyQrcode

@dynamic version;
@dynamic username;
@dynamic encriptionPri;
@dynamic passwordHint;
@dynamic phone;
@dynamic avatar;
@dynamic connectId;

typedef struct ExoprtPrivkeyQrcode__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  NSString *username;
  NSString *encriptionPri;
  NSString *passwordHint;
  NSString *phone;
  NSString *avatar;
  NSString *connectId;
} ExoprtPrivkeyQrcode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = ExoprtPrivkeyQrcode_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExoprtPrivkeyQrcode__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = ExoprtPrivkeyQrcode_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExoprtPrivkeyQrcode__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encriptionPri",
        .dataTypeSpecific.className = NULL,
        .number = ExoprtPrivkeyQrcode_FieldNumber_EncriptionPri,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExoprtPrivkeyQrcode__storage_, encriptionPri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "passwordHint",
        .dataTypeSpecific.className = NULL,
        .number = ExoprtPrivkeyQrcode_FieldNumber_PasswordHint,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ExoprtPrivkeyQrcode__storage_, passwordHint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = ExoprtPrivkeyQrcode_FieldNumber_Phone,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ExoprtPrivkeyQrcode__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = ExoprtPrivkeyQrcode_FieldNumber_Avatar,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ExoprtPrivkeyQrcode__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectId",
        .dataTypeSpecific.className = NULL,
        .number = ExoprtPrivkeyQrcode_FieldNumber_ConnectId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ExoprtPrivkeyQrcode__storage_, connectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExoprtPrivkeyQrcode class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExoprtPrivkeyQrcode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ContactsNotificatedAddress

@implementation ContactsNotificatedAddress

@dynamic addressesArray, addressesArray_Count;

typedef struct ContactsNotificatedAddress__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *addressesArray;
} ContactsNotificatedAddress__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addressesArray",
        .dataTypeSpecific.className = NULL,
        .number = ContactsNotificatedAddress_FieldNumber_AddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ContactsNotificatedAddress__storage_, addressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ContactsNotificatedAddress class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ContactsNotificatedAddress__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferHistory

@implementation TransferHistory

@dynamic transferUsersArray, transferUsersArray_Count;

typedef struct TransferHistory__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transferUsersArray;
} TransferHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transferUsersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = TransferHistory_FieldNumber_TransferUsersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransferHistory__storage_, transferUsersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferHistory class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferHistory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatCookieHistory

@implementation ChatCookieHistory

@dynamic chatCookiesArray, chatCookiesArray_Count;

typedef struct ChatCookieHistory__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *chatCookiesArray;
} ChatCookieHistory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatCookiesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatCacheCookie),
        .number = ChatCookieHistory_FieldNumber_ChatCookiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatCookieHistory__storage_, chatCookiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatCookieHistory class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatCookieHistory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Luckypackage

@implementation Luckypackage

@dynamic total;
@dynamic fee;
@dynamic amount;
@dynamic type;
@dynamic currency;
@dynamic category;
@dynamic fromAddressesArray, fromAddressesArray_Count;

typedef struct Luckypackage__storage_ {
  uint32_t _has_storage_[1];
  int32_t total;
  int32_t fee;
  int32_t amount;
  int32_t type;
  int32_t category;
  NSString *currency;
  NSMutableArray *fromAddressesArray;
} Luckypackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "total",
        .dataTypeSpecific.className = NULL,
        .number = Luckypackage_FieldNumber_Total,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Luckypackage__storage_, total),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Luckypackage_FieldNumber_Fee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Luckypackage__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = Luckypackage_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Luckypackage__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = Luckypackage_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Luckypackage__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = Luckypackage_FieldNumber_Currency,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Luckypackage__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.className = NULL,
        .number = Luckypackage_FieldNumber_Category,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Luckypackage__storage_, category),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fromAddressesArray",
        .dataTypeSpecific.className = NULL,
        .number = Luckypackage_FieldNumber_FromAddressesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Luckypackage__storage_, fromAddressesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Luckypackage class]
                                     rootClass:[ProtofileRoot class]
                                          file:ProtofileRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Luckypackage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
